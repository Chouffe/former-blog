<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://simplelambda.com' rel='self' type='application/rss+xml'/>
<title>
λambda Closure
</title>
<link>
http://simplelambda.com
</link>
<description>
This blog is awesome
</description>
<lastBuildDate>
Tue, 01 Mar 2016 10:59:01 -0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</guid>
<link>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</link>
<title>
Snake the game - A Functional Programming Style tutorial for ClojureScript and Reagent
</title>
<description>
&lt;h2&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;Functional Programming is finally getting broadly used in the frontend! This is fantastic news! I have been programming in Clojure/ClojureScript for about 2 years. It seems to me that nothing can get quite close to it in terms of productivity and simplicity. So let's give it a try and see what else is out there.&lt;h2&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h2&gt;I am starting this series of tutorials to compare different frontend abstractions to build modern real world applications. The goal is to provide the reader with some comparisons on different functional abstractions. I will focus on the following ones:&lt;ul&gt;&lt;li&gt;ClojureScript + Reagent&lt;/li&gt;&lt;li&gt;ClojureScript + Om&lt;/li&gt;&lt;li&gt;Elm&lt;/li&gt;&lt;li&gt;ReactJS&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;clojurescript&amp;#95;and&amp;#95;reagent&quot;&gt;&lt;/a&gt;ClojureScript and Reagent&lt;/h2&gt;The first post will focus on building a Snake Game in ClojureScript and Reagent, using the library re-frame. All the code is available on &lt;a href='https://github.com/Chouffe/snake'&gt;my github&lt;/a&gt;. Here is a demo of what we are about to build:&lt;p&gt;&lt;link href=&quot;/posts/css/snake.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;snake&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/snake.js&quot;&gt;&lt;/script&gt; &lt;script&gt;snake.core.init();&lt;/script&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;setup&quot;&gt;&lt;/a&gt;Setup&lt;/h2&gt;To get started, just go read about &lt;a href='https://github.com/Day8/re-frame'&gt;re-frame&lt;/a&gt;. Then run the following lein command to start an re-frame app.&lt;blockquote&gt;&lt;p&gt; lein new re-frame &lt;project-name&gt; &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That should generate the following project dir:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.
├── dev-resources
├── figwheel&amp;#95;server.log
├── project.clj
├── README.md
├── resources
│   └── public
├── src
│   ├── clj
│   └── cljs
├── target
│   ├── classes
│   ├── figwheel&amp;#95;temp
│   └── stale
└── test
    └── cljs
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;modeling&amp;#95;state&quot;&gt;&lt;/a&gt;Modeling State&lt;/h2&gt;The following concepts are needed to properly model the Snake Game:&lt;ul&gt;&lt;li&gt;Board&lt;ul&gt;&lt;li&gt;width&lt;/li&gt;&lt;li&gt;height&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Snake&lt;ul&gt;&lt;li&gt;position&lt;/li&gt;&lt;li&gt;direction&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Apple position&lt;/li&gt;&lt;li&gt;Points&lt;/li&gt;&lt;li&gt;Is the game over?&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;The board is defined by a number of rows and columns.  simplest way to express it is to use a tuple of 2 elements &lt;code&gt;&amp;#91;width height&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-board &amp;#91;&amp;#93; &amp;#91;35 25&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;snake&quot;&gt;&lt;/a&gt;Snake&lt;/h3&gt;The snake is modeled with a direction in &lt;code&gt;#{:up :down :right :left}&lt;/code&gt; and a sequence of positions &lt;code&gt;&amp;#91;&amp;#91;x1 y1&amp;#93; &amp;#91;x2 y2&amp;#93;&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-snake &amp;#91;&amp;#93;
  {:direction :right
   :body &amp;#91;&amp;#91;3 2&amp;#93; &amp;#91;2 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;0 2&amp;#93;&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;state&quot;&gt;&lt;/a&gt;State&lt;/h3&gt;The game state is the combination of all the above&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-free-position &amp;#91;board unavailable-positions&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; board
       positions
       &amp;#40;remove &amp;#40;set unavailable-positions&amp;#41;&amp;#41;
       rand-nth&amp;#41;&amp;#41;

&amp;#40;defn init-state &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;snake &amp;#40;init-snake&amp;#41;
        board &amp;#40;init-board&amp;#41;&amp;#93;
    {:running? true
     :board board
     :snake snake
     :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;
     :points 0}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;views&quot;&gt;&lt;/a&gt;The views&lt;/h2&gt;Reagent is a simple wrapper around React. We need to design our views as pure functions of the app-state. Re-frame achieves this by using FRP and subscribing to state changes.&lt;h3&gt;&lt;a name=&quot;score&quot;&gt;&lt;/a&gt;Score&lt;/h3&gt;The view function is very simple. It subscribes to the points value in the app-state.&lt;pre&gt;&lt;code&gt;&amp;#40;defn score &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;points &amp;#40;subscribe &amp;#91;:points&amp;#93;&amp;#41;&amp;#93;
    &amp;#91;:div.score &amp;quot;Score: &amp;quot; @points&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how a subscription gets registered:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;register-sub :points &amp;#40;fn &amp;#91;db&amp;#93; &amp;#40;reaction &amp;#40;:points @db&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;This view will be created with simple html elements. Canvas could have been used for that instead. Here, each cell of the board is a table cell with a given CSS class.&lt;pre&gt;&lt;code&gt;&amp;#40;defn board &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;board &amp;#40;subscribe &amp;#91;:board&amp;#93;&amp;#41;
        snake &amp;#40;subscribe &amp;#91;:snake&amp;#93;&amp;#41;
        food &amp;#40;subscribe &amp;#91;:food&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;&amp;#91;width height&amp;#93; @board
            {:keys &amp;#91;body&amp;#93;} @snake&amp;#93;
        &amp;#40;into &amp;#91;:table.stage&amp;#93;
              &amp;#40;for &amp;#91;y &amp;#40;range height&amp;#41;&amp;#93;
                &amp;#40;into &amp;#91;:tr {:key y}&amp;#93;
                      &amp;#40;mapv &amp;#40;fn &amp;#91;x&amp;#93; &amp;#91;:td {:key &amp;#40;str x &amp;quot;.&amp;quot; y&amp;#41;
                                          :class &amp;#40;cell-class &amp;#91;x y&amp;#93; @food &amp;#40;set body&amp;#41;&amp;#41;}&amp;#93;&amp;#41;
                            &amp;#40;range width&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private cell-class &amp;#91;position food-position snake-body-positions&amp;#93;
  &amp;#40;cond
    &amp;#40;= position food-position&amp;#41;          &amp;quot;food&amp;quot;
    &amp;#40;get snake-body-positions position&amp;#41; &amp;quot;snake&amp;quot;
    :else                               &amp;quot;empty&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;over&quot;&gt;&lt;/a&gt;Game Over&lt;/h3&gt;When the game is over, an overlay is added on top of the board with a replay button.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game-over &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;running? &amp;#40;subscribe &amp;#91;:running?&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;if @running?
        &amp;#91;:div&amp;#93;
        &amp;#91;:div.overlay
         &amp;#91;:div.play {:on-click #&amp;#40;dispatch &amp;#91;:start-game&amp;#93;&amp;#41;}
          &amp;#91;:h1 &amp;quot;↺&amp;quot;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&quot;&gt;&lt;/a&gt;Game&lt;/h3&gt;The main view is then composed of the different components.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game &amp;#91;&amp;#93;
  &amp;#91;:div.game
   &amp;#91;score&amp;#93;
   &amp;#91;board&amp;#93;
   &amp;#91;game-over&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;The components are then mounted to the DOM with the function &lt;code&gt;run&lt;/code&gt; defined below.The main entrypoint of an re-frame app is the &lt;code&gt;init&lt;/code&gt; function.&lt;pre&gt;&lt;code&gt;&amp;#40;defn run &amp;#91;&amp;#93;
  &amp;#40;reagent/render &amp;#91;views/game&amp;#93;
                  &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;game&amp;#95;loop&quot;&gt;&lt;/a&gt;Game Loop&lt;/h2&gt;The game loop is handled with a set-interval call that will create a new game state based on the current one. That state will then be handled by React (Reagent) and the view will get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;defonce snake-moving
   &amp;#40;js/setInterval #&amp;#40;dispatch &amp;#91;:next-state&amp;#93;&amp;#41; 100&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Every 100ms, the message :next-state is sent to the handler.&lt;h2&gt;&lt;a name=&quot;handlers&quot;&gt;&lt;/a&gt;Handlers&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;initialization&quot;&gt;&lt;/a&gt;Game Initialization&lt;/h3&gt;In order to initialize the game, a handler &lt;code&gt;:start-game&lt;/code&gt; is created. It resets the initial state.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler :start-game &amp;#40;fn  &amp;#91;&amp;#95; &amp;#95;&amp;#93; &amp;#40;db/init-state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And the &lt;code&gt;init&lt;/code&gt; function is updated accordingly.&lt;pre&gt;&lt;code&gt;&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;dispatch-sync &amp;#91;:start-game&amp;#93;&amp;#41;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;changing&amp;#95;direction&quot;&gt;&lt;/a&gt;Changing Direction&lt;/h3&gt;When a player interacts with the keyboard (Up, Down, Left, Right or h, j, k, l for vim users), the direction of the snake should get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler
   :change-direction
   &amp;#40;fn &amp;#91;db &amp;#91;&amp;#95; direction&amp;#93;&amp;#93;
      &amp;#40;assert &amp;#40;get #{:up :down :left :right} direction&amp;#41;&amp;#41;
      &amp;#40;assoc-in db &amp;#91;:snake :direction&amp;#93; direction&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;A handler is just a reducer function that takes in the value of the app-state &lt;code&gt;db&lt;/code&gt; and an action and returns a new app-state.Then, a keyboard listener is defined to catch the keystrokes mentioned above.&lt;pre&gt;&lt;code&gt;&amp;#40;def key-code-&amp;gt;move
   &amp;quot;Mapping from the integer key code to the direction keyword&amp;quot;
   {38  :up   ; Up Arrow
    75  :up   ; k
    40  :down ; Down Arrow
    74  :down ; j
    39  :right ; Right Arrow
    76  :right ; l
    37  :left  ; Left Arrow
    72  :left  ; h
    }&amp;#41;

&amp;#40;defonce key-handler
   &amp;#40;events/listen
      js/window
      &amp;quot;keydown&amp;quot;
      &amp;#40;fn  &amp;#91;e&amp;#93;
         &amp;#40;let &amp;#91;key-code &amp;#40;.-keyCode e&amp;#41;&amp;#93;
            &amp;#40;when &amp;#40;contains? key-code-&amp;gt;move key-code&amp;#41;
               &amp;#40;re-frame/dispatch &amp;#91;:change-direction &amp;#40;key-code-&amp;gt;move key-code&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;next&amp;#95;state&quot;&gt;&lt;/a&gt;Next State&lt;/h3&gt;The last thing to do is to implement the handler next-state that will move the snake given the direction and the state of the game.&lt;h4&gt;&lt;a name=&quot;collisions&quot;&gt;&lt;/a&gt;Collisions&lt;/h4&gt;The game is lost when the snake hits a wall or eats itself.&lt;pre&gt;&lt;code&gt;&amp;#40;defn collision? &amp;#91;snake board&amp;#93;
    &amp;#40;or &amp;#40;wall? next-head board&amp;#41; &amp;#40;eat-itself? snake&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn eat-itself? &amp;#91;{:keys &amp;#91;body&amp;#93; :as snake}&amp;#93;
  &amp;#40;boolean &amp;#40;get &amp;#40;into #{} body&amp;#41; &amp;#40;next-head-position snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn valid? &amp;#91;&amp;#91;x y :as position&amp;#93; &amp;#91;width height :as board&amp;#93;&amp;#93;
  &amp;#40;and &amp;#40;&amp;lt; -1 x width&amp;#41; &amp;#40;&amp;lt; -1 y height&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def wall? &amp;#40;complement valid?&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;re-frame/register-handler
   :next-state
   &amp;#40;fn &amp;#91;db &amp;#95;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;snake food board running?&amp;#93;} db&amp;#93;
         &amp;#40;cond
            &amp;#40;db/collision? snake board&amp;#41; &amp;#40;assoc db :running? false&amp;#41;
            &amp;#40;db/food? &amp;#40;db/next-head-position snake&amp;#41; food&amp;#41; &amp;#40;-&amp;gt; db
                                                              &amp;#40;update :points inc&amp;#41;
                                                              &amp;#40;update :snake db/move-snake&amp;#41;
                                                              &amp;#40;dissoc :food&amp;#41;
                                                              &amp;#40;update :snake db/grow-snake snake&amp;#41;
                                                              &amp;#40;db/rand-food&amp;#41;&amp;#41;
            :else &amp;#40;update db :snake db/move-snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;move-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn next-head-position
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x y :as pos&amp;#93; &amp;#40;first body&amp;#41;&amp;#93;
    &amp;#40;case direction
      :left  &amp;#91;&amp;#40;dec x&amp;#41; y&amp;#93;
      :right &amp;#91;&amp;#40;inc x&amp;#41; y&amp;#93;
      :up    &amp;#91;x &amp;#40;dec y&amp;#41;&amp;#93;
      :down  &amp;#91;x &amp;#40;inc y&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn move-snake
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;update snake :body &amp;#40;fn &amp;#91;body&amp;#93; &amp;#40;cons &amp;#40;next-head-position snake&amp;#41;
                                       &amp;#40;drop-last body&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;grow-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn grow-snake
  &amp;#91;snake previous-snake&amp;#93;
  &amp;#40;update snake :body concat &amp;#91;&amp;#40;last &amp;#40;:body previous-snake&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And finally, here is &lt;code&gt;rand-food&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-food &amp;#91;{:keys &amp;#91;snake board&amp;#93; :as state}&amp;#93;
  &amp;#40;assoc state :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;development&amp;#95;environment&quot;&gt;&lt;/a&gt;Development Environment&lt;/h2&gt;Something that is often not discussed is tooling. Tools are everything. I spent a lot of time fine tuning my environment to increase my productiviy.To be honest, the ecosystem and tooling around Clojure and ClojureScript are just amazing.&lt;h3&gt;&lt;a name=&quot;figwheel&quot;&gt;&lt;/a&gt;Figwheel&lt;/h3&gt;To develop this game I used &lt;a href='https://github.com/bhauman/lein-figwheel'&gt;figwheel&lt;/a&gt; which enables live pushes to the clients. Here is a &lt;a href='https://www.youtube.com/watch?v=KZjFVdU8VLI'&gt;quick demo&lt;/a&gt; of interactive development in ClojureScript.&lt;p&gt;This is what my workflow looks like when developing:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Type something in my text-editor&lt;/li&gt;&lt;li&gt;Save changes&lt;/li&gt;&lt;li&gt;See live changes in the browser&lt;ul&gt;&lt;li&gt;live code reloading&lt;/li&gt;&lt;li&gt;live CSS reloading&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Repeat until done&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I get instant feedback without leaving my text editor!&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/img/snake/liveupdate.png&quot; alt=&quot;Dev Environment&quot; title=&quot;Figwheel and Interactive Development&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;Re-frame is a well thought out combination of &lt;strong&gt;reactive programming&lt;/strong&gt;, &lt;strong&gt;functional programming&lt;/strong&gt; and &lt;strong&gt;immutable data&lt;/strong&gt;.&lt;p&gt;It lets developers focus on the core application in a beautifully simple way. Re-frame emerged from ideas developed in Om, Elm and Flux that we are going to study next.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;pros&quot;&gt;&lt;/a&gt;Pros&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Clojure ❤&lt;ul&gt;&lt;li&gt;Immutability&lt;/li&gt;&lt;li&gt;Lisp&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Local states are just atoms captured in a closure. Local states can be shared between components.&lt;/li&gt;&lt;li&gt;Reagent is faster than React: All the checks for changes are pointer comparison (thanks to Clojure's immutability)&lt;/li&gt;&lt;li&gt;Pure functions: the side effects are pushed to the system's boundary. They should only exist in the event handlers.&lt;/li&gt;&lt;li&gt;Composition via reactive data flows (unidirectional graph)&lt;/li&gt;&lt;li&gt;Extremely simple (200 lines of code to implement re-frame)&lt;/li&gt;&lt;li&gt;Decomplects view, state, business logic in a functional way&lt;h3&gt;&lt;a name=&quot;cons&quot;&gt;&lt;/a&gt;Cons&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;The views are only in Hiccup Style for now (Clojure Data Structure). That is hard for designers to create their own components...&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 29 Feb 2016 00:00:00 -0800
</pubDate>
</item>
</channel>
</rss>
