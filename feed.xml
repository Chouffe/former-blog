<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://simplelambda.com' rel='self' type='application/rss+xml'/>
<title>
Î»ambda Closure
</title>
<link>
http://simplelambda.com
</link>
<description>
This blog is awesome
</description>
<lastBuildDate>
Fri, 04 Mar 2016 09:31:15 -0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://simplelambda.com/posts/2016-03-03-mandelbrot-set.html
</guid>
<link>
http://simplelambda.com/posts/2016-03-03-mandelbrot-set.html
</link>
<title>
Fractals - Exploration of the Mandelbrot Set with ClojureScript and React
</title>
<description>
&lt;h2&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;A fractal is a mathematical object that exhibits a pattern that repeats itself at every scale. They are very interesting mathematical concepts because they differ from regular geometrical figures. How does one measure the length a fractal curve? The Mandelbrot Set is a closed area of the complex plane but still, its perimeter is not a finite number. Sophisticated structures arise from very simple rules!&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/2/21/Mandel_zoom_00_mandelbrot_set.jpg&quot; alt=&quot;Mandelbrot Set&quot; /&gt;&lt;/p&gt;&lt;p&gt;The goal of this post is to see how we can build a simple UI tool to visualize the Mandelbrot Set.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/ce/Mandelbrot_zoom.gif&quot; alt=&quot;Mandelbrot Repeating Pattern&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;mandelbrot&amp;#95;set&quot;&gt;&lt;/a&gt;Mandelbrot Set&lt;/h2&gt;&lt;p&gt;The &lt;strong&gt;Mandelbrot Set&lt;/strong&gt; is the set of complex numbers such that the function f(z) = z&lt;sup&gt;2&lt;/sup&gt; + c does not diverge when iterated.&lt;/p&gt;&lt;p&gt;A practical test is often to iterate n times and to check whether the value remains bouded (eg. &lt; 2)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;f(z)&lt;/li&gt;&lt;li&gt;f(f(z))&lt;/li&gt;&lt;li&gt;f(f(f(z))) ...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This fractal is particularly interesting because it is one of the best-known examples of mathematical visualization or mathematical art. It has also some real world applications in complex dynamics.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;modeling&amp;#95;complex&amp;#95;numbers&quot;&gt;&lt;/a&gt;Modeling complex numbers&lt;/h2&gt;&lt;p&gt;The Mandelbrot Set is a subset of the Complex plane. We need a way to represent &lt;a href='https://en.wikipedia.org/wiki/Complex_number'&gt;complex numbers&lt;/a&gt; in Clojure. As a reminder, complex numbers are numbers that can be expressed in the form a + b&lt;em&gt;i&lt;/em&gt; where a and b are real numbers and &lt;em&gt;i&lt;/em&gt; is the imaginary unit.&lt;/p&gt;&lt;p&gt;I will not get really fancy implementing the complex operations required to generate the Mandelbrot Set. I may implement a robust library for complex numbers in the future but for now, we will just go with 3 operations:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;add: adds two complex numbers&lt;/li&gt;&lt;li&gt;mult: multiplies two complex numbers&lt;/li&gt;&lt;li&gt;abs: norm of a complex number&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Also, there are two common ways to represent complex numbers. The first one is a tuple of imaginary part (Im) and real part (Re). The second one uses the distance from O (origin in the Complex plane) and the angle of OP and the x-axis (which is known as the argument of the complex number). Sometimes, operations can be performed more efficiently in one representation or the other. For now, I will only provide one representation for the complex numbers:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns mandelbrot.complex&amp;#41;

&amp;#40;defn z &amp;#91;x y&amp;#93; &amp;#91;x y&amp;#93;&amp;#41;

&amp;#40;defn add &amp;#91;z1 z2&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x1 y1&amp;#93; z1
        &amp;#91;x2 y2&amp;#93; z2&amp;#93;
    &amp;#91;&amp;#40;+ x1 x2&amp;#41; &amp;#40;+ y1 y2&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn mult &amp;#91;z1 z2&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x1 y1&amp;#93; z1
        &amp;#91;x2 y2&amp;#93; z2&amp;#93;
    &amp;#91;&amp;#40;- &amp;#40;&amp;#42; x1 x2&amp;#41;
        &amp;#40;&amp;#42; y1 y2&amp;#41;&amp;#41;
     &amp;#40;+ &amp;#40;&amp;#42; y1 x2&amp;#41;
        &amp;#40;&amp;#42; y2 x1&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn abs &amp;#91;z&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x y&amp;#93; z&amp;#93;
    &amp;#40;#?&amp;#40;:clj Math/sqrt :cljs js/Math.sqrt&amp;#41; &amp;#40;+ &amp;#40;&amp;#42; x x&amp;#41; &amp;#40;&amp;#42; y y&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;set&amp;#95;generation&quot;&gt;&lt;/a&gt;Set generation&lt;/h2&gt;&lt;p&gt;We only need a function &lt;code&gt;mandelbrot?&lt;/code&gt; that takes in a complex number &lt;code&gt;z&lt;/code&gt; and returns a boolean. &lt;code&gt;z&lt;/code&gt; is in the set if and only if it does not diverge when repeatedly applying the function f.&lt;/p&gt;&lt;p&gt;f(u) = u&lt;sup&gt;2&lt;/sup&gt; + z&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn mandelbrot? &amp;#91;z&amp;#93;
  &amp;#40;let &amp;#91;max-iter 20&amp;#93;
    &amp;#40;loop &amp;#91;k 1
           m &amp;#40;iterate #&amp;#40;c/add z &amp;#40;c/mult % %&amp;#41;&amp;#41; &amp;#40;c/z 0 0&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;if &amp;#40;and &amp;#40;&amp;gt; max-iter k&amp;#41; &amp;#40;&amp;lt; &amp;#40;c/abs &amp;#40;first m&amp;#41;&amp;#41; 2&amp;#41;&amp;#41;
        &amp;#40;recur &amp;#40;inc k&amp;#41; &amp;#40;rest m&amp;#41;&amp;#41;
        &amp;#40;= max-iter k&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can already generate the mandelbrot set with this &lt;code&gt;mandelbrot?&lt;/code&gt; function. In order to make it look nicer, we can return the number of iterations needed to see that it diverges. We will then be able to display a gradient of colors instead of only 2 colors.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn &amp;#94;:private mandelbrot-n-iter-aux
  &amp;#91;z u n-max k&amp;#93;
  &amp;#40;cond
    &amp;#40;&amp;gt; &amp;#40;c/abs u&amp;#41; 2&amp;#41; &amp;#91;false k&amp;#93;
    &amp;#40;&amp;gt;= k n-max&amp;#41; &amp;#91;true k&amp;#93;
    :else &amp;#40;recur z &amp;#40;c/add z &amp;#40;c/mult u u&amp;#41;&amp;#41; n-max &amp;#40;inc k&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private mandelbrot-n-iter &amp;#91;z&amp;#93;
  &amp;#40;mandelbrot-n-iter-aux z &amp;#40;c/z 0 0&amp;#41; 20 1&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private mandelbrot-value &amp;#91;range-x range-y&amp;#93;
  &amp;#40;for &amp;#91;y range-y
        x range-x&amp;#93;
    &amp;#40;let &amp;#91;&amp;#91;in-set? k&amp;#93; &amp;#40;mandelbrot-n-iter &amp;#40;c/z x y&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;if in-set? 0 k&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;I built a simple visualization tool with ClojureScript, React, re-frame and the mandelbrot functions discussed above. The colors can be changed by sliding the ranges, zooming is enabled and clicking on the fractal moves it accordingly.&lt;/p&gt;&lt;p&gt;&lt;link href=&quot;/posts/css/mandelbrot.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;mandelbrot&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/mandelbrot.js&quot;&gt;&lt;/script&gt; &lt;script&gt;mandelbrot.core.init();&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The code is fully available on &lt;a href='https://github.com/Chouffe/fractals'&gt;my github&lt;/a&gt;. Feel free to explore the code and explore your own fractal objects.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;&lt;p&gt;The Mandelbrot Set is a very simple yet sophisticated mathematical object that derives from very simple rules. I'd like to generate other fractal objects (Julia, Sierpinski Gasket) in a next project.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 03 Mar 2016 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
http://simplelambda.com/posts/2016-03-01-autocomplete.html
</guid>
<link>
http://simplelambda.com/posts/2016-03-01-autocomplete.html
</link>
<title>
Autocomplete - Trie Datastructure in Clojure and ClojureScript
</title>
<description>
&lt;h2&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;A &lt;a href='https://en.wikipedia.org/wiki/Trie'&gt;trie&lt;/a&gt; is a powerful datastructure often used for dictionary representation. The goal of this post is to implement a trie in Clojure and ClojureScript. Then we will build an autocomplete system.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;trie&quot;&gt;&lt;/a&gt;Trie&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;A trie or prefix tree (as they can be searched by prefixes) is an ordered datastructure that is used to store an associative array where the keys are ususally strings.&lt;/li&gt;&lt;li&gt;All the descendants of a node have a common prefix of the string associated with that node.&lt;/li&gt;&lt;li&gt;The root node is the empty string&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/600px-Trie_example.svg.png&quot; alt=&quot;Trie Datastructure&quot; /&gt;&lt;/li&gt;&lt;li&gt;A prefix tree allows for quick search, insert and delete operations O(log k) where k is the length of the prefix string&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;&lt;link href=&quot;/posts/css/autocomplete.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;autocomplete-app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/autocomplete.js&quot;&gt;&lt;/script&gt; &lt;script&gt;autocomplete.core.init();&lt;/script&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The left input field allows you to add strings in the trie&lt;/li&gt;&lt;li&gt;the right input field performs autocompletes&lt;/li&gt;&lt;li&gt;The trie is represented as nested list for visualization&lt;/li&gt;&lt;li&gt;Some preset lists of strings can be loaded by clicking on the buttons &lt;code&gt;Reset&lt;/code&gt;, &lt;code&gt;Small Alphabet&lt;/code&gt;, &lt;code&gt;Countries&lt;/code&gt; or &lt;code&gt;Languages&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;The colors of the elements in the trie change if they match the prefix-string&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h2&gt;&lt;p&gt;You can find my trie implementation on &lt;a href='https://github.com/Chouffe/clj-trie'&gt;github&lt;/a&gt; and &lt;a href='https://clojars.org/trie'&gt;clojars&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;datastructure&quot;&gt;&lt;/a&gt;Datastructure&lt;/h3&gt;&lt;p&gt;Each node of the trie will contain the following keys:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: the current prefix string at that node, eg &quot;te&quot;, &quot;in&quot;...&lt;/li&gt;&lt;li&gt;&lt;strong&gt;children&lt;/strong&gt;: a hashmap from char to node&lt;/li&gt;&lt;li&gt;&lt;strong&gt;key&lt;/strong&gt;: flag to say if the value of that node is in the dictionary&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The empty trie is then&lt;pre&gt;&lt;code&gt;&amp;#40;defn- make-empty-trie
  &amp;quot;Creates an empty trie with empty lexicon.&amp;quot;
  &amp;#91;&amp;#93;
  {:value &amp;quot;&amp;quot;}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;operations&quot;&gt;&lt;/a&gt;Operations&lt;/h3&gt;&lt;h4&gt;&lt;a name=&quot;conj&amp;#95;-&amp;#95;adding&amp;#95;to&amp;#95;a&amp;#95;trie&quot;&gt;&lt;/a&gt;Conj - Adding to a trie&lt;/h4&gt;When adding a string to a trie, we need to perform the following:&lt;ul&gt;&lt;li&gt;Go down the tree following the characters of the string&lt;/li&gt;&lt;li&gt;Create nodes (if they do not exist yet) unitl the last character of the string is reached&lt;/li&gt;&lt;li&gt;Add/Update the node with a flag to say that this word (path from root to the node) has been added to the trie&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- conj-trie
  &amp;#91;{:keys &amp;#91;value children&amp;#93; :as trie} &amp;#91;c &amp;amp; cs :as string&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;ch &amp;#40;str c&amp;#41;&amp;#93;
    &amp;#40;cond
      ; A leaf is reached and last letter in string
      &amp;#40;and &amp;#40;not &amp;#40;get children ch&amp;#41;&amp;#41; &amp;#40;not &amp;#40;seq cs&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children &amp;#40;str c&amp;#41;&amp;#93; {:value &amp;#40;str value c&amp;#41; :key &amp;#40;gensym&amp;#41;}&amp;#41;

      ; A leaf is reached and still some letters
      &amp;#40;and &amp;#40;not &amp;#40;get children ch&amp;#41;&amp;#41; &amp;#40;seq cs&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children ch&amp;#93; &amp;#40;conj-trie {:value &amp;#40;str value c&amp;#41;} cs&amp;#41;&amp;#41;

      ; No more letters but already present in the trie
      &amp;#40;and &amp;#40;get children ch&amp;#41; &amp;#40;not &amp;#40;seq cs&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children ch :key&amp;#93; &amp;#40;gensym&amp;#41;&amp;#41;

      ; Already in trie and still letters
      &amp;#40;and &amp;#40;get children ch&amp;#41; &amp;#40;seq cs&amp;#41;&amp;#41;
      &amp;#40;update-in trie &amp;#91;:children ch&amp;#93; conj-trie cs&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then adding a set of strings is just a fold over the collection&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- into-trie
  &amp;#91;trie coll&amp;#93;
  &amp;#40;reduce conj-trie trie coll&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the Clojure Datastructure that represents the trie&lt;pre&gt;&lt;code&gt;{:value &amp;quot;&amp;quot;,
 :children
 {&amp;quot;t&amp;quot;
  {:value &amp;quot;t&amp;quot;,
   :children
   {&amp;quot;e&amp;quot;
    {:value &amp;quot;te&amp;quot;,
     :children
     {&amp;quot;a&amp;quot; {:value &amp;quot;tea&amp;quot;, :key G&amp;#95;&amp;#95;22475},
      &amp;quot;d&amp;quot; {:value &amp;quot;ted&amp;quot;, :key G&amp;#95;&amp;#95;22477},
      &amp;quot;n&amp;quot; {:value &amp;quot;ten&amp;quot;, :key G&amp;#95;&amp;#95;22478}}},
    &amp;quot;o&amp;quot; {:value &amp;quot;to&amp;quot;, :key G&amp;#95;&amp;#95;22476}}},
  &amp;quot;a&amp;quot; {:value &amp;quot;a&amp;quot;, :key G&amp;#95;&amp;#95;22479},
  &amp;quot;i&amp;quot;
  {:value &amp;quot;i&amp;quot;,
   :key G&amp;#95;&amp;#95;22480,
   :children
   {&amp;quot;n&amp;quot;
    {:value &amp;quot;in&amp;quot;,
     :key G&amp;#95;&amp;#95;22481,
     :children {&amp;quot;n&amp;quot; {:value &amp;quot;inn&amp;quot;, :key G&amp;#95;&amp;#95;22482}}}}}}}
 &lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;search&quot;&gt;&lt;/a&gt;Search&lt;/h3&gt;To search into the trie (autocomplete given a prefix string), we only need to go down the trie following the prefix string characters and then collect the elements in this subtree.&lt;h4&gt;&lt;a name=&quot;apply-trie&quot;&gt;&lt;/a&gt;apply-trie&lt;/h4&gt;&lt;/p&gt;&lt;p&gt;The &lt;code&gt;apply-trie&lt;/code&gt; function goes down the trie following the characters and then call the funtion &lt;code&gt;trie-&amp;gt;seq&lt;/code&gt; on this subtree.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- apply-trie
  &amp;#91;{:keys &amp;#91;value key children&amp;#93; :as trie} &amp;#91;c &amp;amp; cs :as string&amp;#93;&amp;#93;
  &amp;#40;cond
    &amp;#40;not &amp;#40;seq string&amp;#41;&amp;#41;           &amp;#40;trie-&amp;gt;seq trie&amp;#41;
    &amp;#40;not &amp;#40;get children &amp;#40;str c&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93;
    :else                        &amp;#40;recur &amp;#40;get children &amp;#40;str c&amp;#41;&amp;#41; cs&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;trie-&gt;seq&quot;&gt;&lt;/a&gt;trie-&gt;seq&lt;/h4&gt;This function is just a DFS on the given trie and returns the element in order.&lt;pre&gt;&lt;code&gt;&amp;#40;defn- trie-&amp;gt;seq
  &amp;quot;Returns all the elements inserted in trie as a sequence.&amp;quot;
  &amp;#91;{:keys &amp;#91;value children key&amp;#93; :as trie}&amp;#93;
  &amp;#40;loop &amp;#91;stack &amp;#91;trie&amp;#93;
         words &amp;#91;&amp;#93;&amp;#93;
    &amp;#40;if &amp;#40;not &amp;#40;seq stack&amp;#41;&amp;#41;
      &amp;#40;seq words&amp;#41;
      &amp;#40;let &amp;#91;{:keys &amp;#91;value children key&amp;#93;} &amp;#40;peek stack&amp;#41;&amp;#93;
        &amp;#40;recur &amp;#40;into &amp;#40;pop stack&amp;#41; &amp;#40;vals children&amp;#41;&amp;#41;
               &amp;#40;if key &amp;#40;conj words value&amp;#41; words&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;protocols&amp;#95;and&amp;#95;interfaces&quot;&gt;&lt;/a&gt;Protocols and Interfaces&lt;/h3&gt;&lt;h4&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h4&gt;To make it feel like a built-in clojure Datastructure, we can define a Trie type that will implement some common clojure interfaces&lt;ul&gt;&lt;li&gt;IPersistentCollection&lt;/li&gt;&lt;li&gt;ILookup&lt;/li&gt;&lt;li&gt;IFn&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The goal is to be able to do the following&lt;/p&gt;&lt;pre&gt;&lt;code&gt;;; Creating a trie
&amp;#40;def autocomplete &amp;#40;trie &amp;#91;&amp;quot;doo&amp;quot; &amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;&amp;#41;&amp;#41;

;; Autocomplete given a prefix-string
&amp;#40;autocomplete &amp;quot;ba&amp;quot;&amp;#41; =&amp;gt; &amp;#91;&amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;

;; Adding to the trie
&amp;#40;&amp;#40;conj autocomplete &amp;quot;baf&amp;quot;&amp;#41; &amp;quot;ba&amp;quot;&amp;#41; =&amp;gt; &amp;#91;&amp;quot;baf&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h4&gt;Clojure implementation&lt;pre&gt;&lt;code&gt;&amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      clojure.lang.ILookup
      &amp;#40;valAt &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;valAt &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      clojure.lang.IPersistentCollection
      &amp;#40;seq &amp;#91;self&amp;#93;     &amp;#40;seq lexicon-set&amp;#41;&amp;#41;
      &amp;#40;cons &amp;#91;self o&amp;#93;  &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;empty &amp;#91;self&amp;#93;   &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
      &amp;#40;equiv &amp;#91;self o&amp;#93; &amp;#40;and &amp;#40;instance? Trie o&amp;#41; &amp;#40;= trie &amp;#40;.trie o&amp;#41;&amp;#41;&amp;#41;&amp;#41;

      clojure.lang.IFn
      &amp;#40;invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ClojureScript implementation&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      cljs.core/ILookup
      &amp;#40;-lookup &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;-lookup &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      cljs.core/ICollection
      &amp;#40;-conj &amp;#91;self o&amp;#93; &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;

      cljs.core/ICounted
      &amp;#40;-count &amp;#91;self&amp;#93; &amp;#40;count lexicon-set&amp;#41;&amp;#41;

      cljs.core/IEmptyableCollection
      &amp;#40;-empty &amp;#91;self&amp;#93; &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;

      cljs.core/IFn
      &amp;#40;-invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then the use of conditional readers and .cljc files allow us to make our trie work for Clojure and ClojureScript&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
#?&amp;#40;:clj
    &amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      clojure.lang.ILookup
      &amp;#40;valAt &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;valAt &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      clojure.lang.IPersistentCollection
      &amp;#40;seq &amp;#91;self&amp;#93;     &amp;#40;seq lexicon-set&amp;#41;&amp;#41;
      &amp;#40;cons &amp;#91;self o&amp;#93;  &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;empty &amp;#91;self&amp;#93;   &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
      &amp;#40;equiv &amp;#91;self o&amp;#93; &amp;#40;and &amp;#40;instance? Trie o&amp;#41; &amp;#40;= trie &amp;#40;.trie o&amp;#41;&amp;#41;&amp;#41;&amp;#41;

      clojure.lang.IFn
      &amp;#40;invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;&amp;#41;

#?&amp;#40;:cljs
    &amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      cljs.core/ILookup
      &amp;#40;-lookup &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;-lookup &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      cljs.core/ICollection
      &amp;#40;-conj &amp;#91;self o&amp;#93; &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;

      cljs.core/ICounted
      &amp;#40;-count &amp;#91;self&amp;#93; &amp;#40;count lexicon-set&amp;#41;&amp;#41;

      cljs.core/IEmptyableCollection
      &amp;#40;-empty &amp;#91;self&amp;#93; &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;

      cljs.core/IFn
      &amp;#40;-invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, the main factory function is the &lt;code&gt;trie&lt;/code&gt; function&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn trie
  &amp;#40;&amp;#91;&amp;#93;     &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;coll&amp;#93; &amp;#40;into &amp;#40;trie&amp;#41; &amp;#40;set &amp;#40;map s/lower-case coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;autocomplete&amp;#95;system&amp;#95;and&amp;#95;ui&quot;&gt;&lt;/a&gt;Autocomplete System and UI&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;I wanted to build a small &lt;a href='#demo'&gt;UI interface&lt;/a&gt; for my trie datastructure. The hard part was the trie visualization. I decided to use nested unordered lists to replicate the tree structure of the trie. I am still not sure convinced that is the best way to visualize a trie but it is good enough for the scope of this project.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;ClojureScript&lt;/li&gt;&lt;li&gt;re-frame (React + Reagent)&lt;/li&gt;&lt;li&gt;trie library developed before&lt;/li&gt;&lt;li&gt;Bootstrap for CSS style&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Actually, it took me more time to build the UI than to build and deploy the trie datastructure. It is hard to come up with good and simple UI components to help the reader understand how this datastructure works.&lt;/p&gt;&lt;p&gt;It is also on my &lt;a href='https://github.com/Chouffe/autocomplete'&gt;github&lt;/a&gt; if you want to take a look at the code :)&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 01 Mar 2016 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</guid>
<link>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</link>
<title>
Snake the game - A Functional Programming Style tutorial for ClojureScript and Reagent
</title>
<description>
&lt;h2&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;Functional Programming is finally getting broadly used in the frontend! This is fantastic news! I have been programming in Clojure/ClojureScript for about 2 years. It seems to me that nothing can get quite close to it in terms of productivity and simplicity. So let's give it a try and see what else is out there.&lt;h2&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h2&gt;I am starting this series of tutorials to compare different frontend abstractions to build modern real world applications. The goal is to provide the reader with some comparisons on different functional abstractions. I will focus on the following ones:&lt;ul&gt;&lt;li&gt;ClojureScript + Reagent&lt;/li&gt;&lt;li&gt;ClojureScript + Om&lt;/li&gt;&lt;li&gt;Elm&lt;/li&gt;&lt;li&gt;ReactJS&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;clojurescript&amp;#95;and&amp;#95;reagent&quot;&gt;&lt;/a&gt;ClojureScript and Reagent&lt;/h2&gt;The first post will focus on building a Snake Game in ClojureScript and Reagent, using the library re-frame. All the code is available on &lt;a href='https://github.com/Chouffe/snake'&gt;my github&lt;/a&gt;. Here is a demo of what we are about to build:&lt;p&gt;&lt;link href=&quot;/posts/css/snake.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;snake&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/snake.js&quot;&gt;&lt;/script&gt; &lt;script&gt;snake.core.init();&lt;/script&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;setup&quot;&gt;&lt;/a&gt;Setup&lt;/h2&gt;To get started, just go read about &lt;a href='https://github.com/Day8/re-frame'&gt;re-frame&lt;/a&gt;. Then run the following lein command to start an re-frame app.&lt;blockquote&gt;&lt;p&gt; lein new re-frame &lt;project-name&gt; &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That should generate the following project dir:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.
âââ dev-resources
âââ figwheel&amp;#95;server.log
âââ project.clj
âââ README.md
âââ resources
âÂ Â  âââ public
âââ src
âÂ Â  âââ clj
âÂ Â  âââ cljs
âââ target
âÂ Â  âââ classes
âÂ Â  âââ figwheel&amp;#95;temp
âÂ Â  âââ stale
âââ test
    âââ cljs
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;modeling&amp;#95;state&quot;&gt;&lt;/a&gt;Modeling State&lt;/h2&gt;The following concepts are needed to properly model the Snake Game:&lt;ul&gt;&lt;li&gt;Board&lt;ul&gt;&lt;li&gt;width&lt;/li&gt;&lt;li&gt;height&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Snake&lt;ul&gt;&lt;li&gt;position&lt;/li&gt;&lt;li&gt;direction&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Apple position&lt;/li&gt;&lt;li&gt;Points&lt;/li&gt;&lt;li&gt;Is the game over?&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;The board is defined by a number of rows and columns.  simplest way to express it is to use a tuple of 2 elements &lt;code&gt;&amp;#91;width height&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-board &amp;#91;&amp;#93; &amp;#91;35 25&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;snake&quot;&gt;&lt;/a&gt;Snake&lt;/h3&gt;The snake is modeled with a direction in &lt;code&gt;#{:up :down :right :left}&lt;/code&gt; and a sequence of positions &lt;code&gt;&amp;#91;&amp;#91;x1 y1&amp;#93; &amp;#91;x2 y2&amp;#93;&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-snake &amp;#91;&amp;#93;
  {:direction :right
   :body &amp;#91;&amp;#91;3 2&amp;#93; &amp;#91;2 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;0 2&amp;#93;&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;state&quot;&gt;&lt;/a&gt;State&lt;/h3&gt;The game state is the combination of all the above&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-free-position &amp;#91;board unavailable-positions&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; board
       positions
       &amp;#40;remove &amp;#40;set unavailable-positions&amp;#41;&amp;#41;
       rand-nth&amp;#41;&amp;#41;

&amp;#40;defn init-state &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;snake &amp;#40;init-snake&amp;#41;
        board &amp;#40;init-board&amp;#41;&amp;#93;
    {:running? true
     :board board
     :snake snake
     :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;
     :points 0}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;views&quot;&gt;&lt;/a&gt;The views&lt;/h2&gt;Reagent is a simple wrapper around React. We need to design our views as pure functions of the app-state. Re-frame achieves this by using FRP and subscribing to state changes.&lt;h3&gt;&lt;a name=&quot;score&quot;&gt;&lt;/a&gt;Score&lt;/h3&gt;The view function is very simple. It subscribes to the points value in the app-state.&lt;pre&gt;&lt;code&gt;&amp;#40;defn score &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;points &amp;#40;subscribe &amp;#91;:points&amp;#93;&amp;#41;&amp;#93;
    &amp;#91;:div.score &amp;quot;Score: &amp;quot; @points&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how a subscription gets registered:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;register-sub :points &amp;#40;fn &amp;#91;db&amp;#93; &amp;#40;reaction &amp;#40;:points @db&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;This view will be created with simple html elements. Canvas could have been used for that instead. Here, each cell of the board is a table cell with a given CSS class.&lt;pre&gt;&lt;code&gt;&amp;#40;defn board &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;board &amp;#40;subscribe &amp;#91;:board&amp;#93;&amp;#41;
        snake &amp;#40;subscribe &amp;#91;:snake&amp;#93;&amp;#41;
        food &amp;#40;subscribe &amp;#91;:food&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;&amp;#91;width height&amp;#93; @board
            {:keys &amp;#91;body&amp;#93;} @snake&amp;#93;
        &amp;#40;into &amp;#91;:table.stage&amp;#93;
              &amp;#40;for &amp;#91;y &amp;#40;range height&amp;#41;&amp;#93;
                &amp;#40;into &amp;#91;:tr {:key y}&amp;#93;
                      &amp;#40;mapv &amp;#40;fn &amp;#91;x&amp;#93; &amp;#91;:td {:key &amp;#40;str x &amp;quot;.&amp;quot; y&amp;#41;
                                          :class &amp;#40;cell-class &amp;#91;x y&amp;#93; @food &amp;#40;set body&amp;#41;&amp;#41;}&amp;#93;&amp;#41;
                            &amp;#40;range width&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private cell-class &amp;#91;position food-position snake-body-positions&amp;#93;
  &amp;#40;cond
    &amp;#40;= position food-position&amp;#41;          &amp;quot;food&amp;quot;
    &amp;#40;get snake-body-positions position&amp;#41; &amp;quot;snake&amp;quot;
    :else                               &amp;quot;empty&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;over&quot;&gt;&lt;/a&gt;Game Over&lt;/h3&gt;When the game is over, an overlay is added on top of the board with a replay button.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game-over &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;running? &amp;#40;subscribe &amp;#91;:running?&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;if @running?
        &amp;#91;:div&amp;#93;
        &amp;#91;:div.overlay
         &amp;#91;:div.play {:on-click #&amp;#40;dispatch &amp;#91;:start-game&amp;#93;&amp;#41;}
          &amp;#91;:h1 &amp;quot;âº&amp;quot;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&quot;&gt;&lt;/a&gt;Game&lt;/h3&gt;The main view is then composed of the different components.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game &amp;#91;&amp;#93;
  &amp;#91;:div.game
   &amp;#91;score&amp;#93;
   &amp;#91;board&amp;#93;
   &amp;#91;game-over&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;The components are then mounted to the DOM with the function &lt;code&gt;run&lt;/code&gt; defined below.The main entrypoint of an re-frame app is the &lt;code&gt;init&lt;/code&gt; function.&lt;pre&gt;&lt;code&gt;&amp;#40;defn run &amp;#91;&amp;#93;
  &amp;#40;reagent/render &amp;#91;views/game&amp;#93;
                  &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;game&amp;#95;loop&quot;&gt;&lt;/a&gt;Game Loop&lt;/h2&gt;The game loop is handled with a set-interval call that will create a new game state based on the current one. That state will then be handled by React (Reagent) and the view will get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;defonce snake-moving
   &amp;#40;js/setInterval #&amp;#40;dispatch &amp;#91;:next-state&amp;#93;&amp;#41; 100&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Every 100ms, the message :next-state is sent to the handler.&lt;h2&gt;&lt;a name=&quot;handlers&quot;&gt;&lt;/a&gt;Handlers&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;initialization&quot;&gt;&lt;/a&gt;Game Initialization&lt;/h3&gt;In order to initialize the game, a handler &lt;code&gt;:start-game&lt;/code&gt; is created. It resets the initial state.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler :start-game &amp;#40;fn  &amp;#91;&amp;#95; &amp;#95;&amp;#93; &amp;#40;db/init-state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And the &lt;code&gt;init&lt;/code&gt; function is updated accordingly.&lt;pre&gt;&lt;code&gt;&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;dispatch-sync &amp;#91;:start-game&amp;#93;&amp;#41;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;changing&amp;#95;direction&quot;&gt;&lt;/a&gt;Changing Direction&lt;/h3&gt;When a player interacts with the keyboard (Up, Down, Left, Right or h, j, k, l for vim users), the direction of the snake should get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler
   :change-direction
   &amp;#40;fn &amp;#91;db &amp;#91;&amp;#95; direction&amp;#93;&amp;#93;
      &amp;#40;assert &amp;#40;get #{:up :down :left :right} direction&amp;#41;&amp;#41;
      &amp;#40;assoc-in db &amp;#91;:snake :direction&amp;#93; direction&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;A handler is just a reducer function that takes in the value of the app-state &lt;code&gt;db&lt;/code&gt; and an action and returns a new app-state.Then, a keyboard listener is defined to catch the keystrokes mentioned above.&lt;pre&gt;&lt;code&gt;&amp;#40;def key-code-&amp;gt;move
   &amp;quot;Mapping from the integer key code to the direction keyword&amp;quot;
   {38  :up   ; Up Arrow
    75  :up   ; k
    40  :down ; Down Arrow
    74  :down ; j
    39  :right ; Right Arrow
    76  :right ; l
    37  :left  ; Left Arrow
    72  :left  ; h
    }&amp;#41;

&amp;#40;defonce key-handler
   &amp;#40;events/listen
      js/window
      &amp;quot;keydown&amp;quot;
      &amp;#40;fn  &amp;#91;e&amp;#93;
         &amp;#40;let &amp;#91;key-code &amp;#40;.-keyCode e&amp;#41;&amp;#93;
            &amp;#40;when &amp;#40;contains? key-code-&amp;gt;move key-code&amp;#41;
               &amp;#40;re-frame/dispatch &amp;#91;:change-direction &amp;#40;key-code-&amp;gt;move key-code&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;next&amp;#95;state&quot;&gt;&lt;/a&gt;Next State&lt;/h3&gt;The last thing to do is to implement the handler next-state that will move the snake given the direction and the state of the game.&lt;h4&gt;&lt;a name=&quot;collisions&quot;&gt;&lt;/a&gt;Collisions&lt;/h4&gt;The game is lost when the snake hits a wall or eats itself.&lt;pre&gt;&lt;code&gt;&amp;#40;defn collision? &amp;#91;snake board&amp;#93;
    &amp;#40;or &amp;#40;wall? next-head board&amp;#41; &amp;#40;eat-itself? snake&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn eat-itself? &amp;#91;{:keys &amp;#91;body&amp;#93; :as snake}&amp;#93;
  &amp;#40;boolean &amp;#40;get &amp;#40;into #{} body&amp;#41; &amp;#40;next-head-position snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn valid? &amp;#91;&amp;#91;x y :as position&amp;#93; &amp;#91;width height :as board&amp;#93;&amp;#93;
  &amp;#40;and &amp;#40;&amp;lt; -1 x width&amp;#41; &amp;#40;&amp;lt; -1 y height&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def wall? &amp;#40;complement valid?&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;re-frame/register-handler
   :next-state
   &amp;#40;fn &amp;#91;db &amp;#95;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;snake food board running?&amp;#93;} db&amp;#93;
         &amp;#40;cond
            &amp;#40;db/collision? snake board&amp;#41; &amp;#40;assoc db :running? false&amp;#41;
            &amp;#40;db/food? &amp;#40;db/next-head-position snake&amp;#41; food&amp;#41; &amp;#40;-&amp;gt; db
                                                              &amp;#40;update :points inc&amp;#41;
                                                              &amp;#40;update :snake db/move-snake&amp;#41;
                                                              &amp;#40;dissoc :food&amp;#41;
                                                              &amp;#40;update :snake db/grow-snake snake&amp;#41;
                                                              &amp;#40;db/rand-food&amp;#41;&amp;#41;
            :else &amp;#40;update db :snake db/move-snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;move-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn next-head-position
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x y :as pos&amp;#93; &amp;#40;first body&amp;#41;&amp;#93;
    &amp;#40;case direction
      :left  &amp;#91;&amp;#40;dec x&amp;#41; y&amp;#93;
      :right &amp;#91;&amp;#40;inc x&amp;#41; y&amp;#93;
      :up    &amp;#91;x &amp;#40;dec y&amp;#41;&amp;#93;
      :down  &amp;#91;x &amp;#40;inc y&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn move-snake
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;update snake :body &amp;#40;fn &amp;#91;body&amp;#93; &amp;#40;cons &amp;#40;next-head-position snake&amp;#41;
                                       &amp;#40;drop-last body&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;grow-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn grow-snake
  &amp;#91;snake previous-snake&amp;#93;
  &amp;#40;update snake :body concat &amp;#91;&amp;#40;last &amp;#40;:body previous-snake&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And finally, here is &lt;code&gt;rand-food&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-food &amp;#91;{:keys &amp;#91;snake board&amp;#93; :as state}&amp;#93;
  &amp;#40;assoc state :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;development&amp;#95;environment&quot;&gt;&lt;/a&gt;Development Environment&lt;/h2&gt;Something that is often not discussed is tooling. Tools are everything. I spent a lot of time fine tuning my environment to increase my productiviy.To be honest, the ecosystem and tooling around Clojure and ClojureScript are just amazing.&lt;h3&gt;&lt;a name=&quot;figwheel&quot;&gt;&lt;/a&gt;Figwheel&lt;/h3&gt;To develop this game I used &lt;a href='https://github.com/bhauman/lein-figwheel'&gt;figwheel&lt;/a&gt; which enables live pushes to the clients. Here is a &lt;a href='https://www.youtube.com/watch?v=KZjFVdU8VLI'&gt;quick demo&lt;/a&gt; of interactive development in ClojureScript.&lt;p&gt;This is what my workflow looks like when developing:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Type something in my text-editor&lt;/li&gt;&lt;li&gt;Save changes&lt;/li&gt;&lt;li&gt;See live changes in the browser&lt;ul&gt;&lt;li&gt;live code reloading&lt;/li&gt;&lt;li&gt;live CSS reloading&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Repeat until done&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I get instant feedback without leaving my text editor!&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/img/snake/liveupdate.png&quot; alt=&quot;Dev Environment&quot; title=&quot;Figwheel and Interactive Development&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;Re-frame is a well thought out combination of &lt;strong&gt;reactive programming&lt;/strong&gt;, &lt;strong&gt;functional programming&lt;/strong&gt; and &lt;strong&gt;immutable data&lt;/strong&gt;.&lt;p&gt;It lets developers focus on the core application in a beautifully simple way. Re-frame emerged from ideas developed in Om, Elm and Flux that we are going to study next.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;pros&quot;&gt;&lt;/a&gt;Pros&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Clojure â¤&lt;ul&gt;&lt;li&gt;Immutability&lt;/li&gt;&lt;li&gt;Lisp&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Local states are just atoms captured in a closure. Local states can be shared between components.&lt;/li&gt;&lt;li&gt;Reagent is faster than React: All the checks for changes are pointer comparison (thanks to Clojure's immutability)&lt;/li&gt;&lt;li&gt;Pure functions: the side effects are pushed to the system's boundary. They should only exist in the event handlers.&lt;/li&gt;&lt;li&gt;Composition via reactive data flows (unidirectional graph)&lt;/li&gt;&lt;li&gt;Extremely simple (200 lines of code to implement re-frame)&lt;/li&gt;&lt;li&gt;Decomplects view, state, business logic in a functional way&lt;h3&gt;&lt;a name=&quot;cons&quot;&gt;&lt;/a&gt;Cons&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;The views are only in Hiccup Style for now (Clojure Data Structure). That is hard for designers to create their own components...&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 29 Feb 2016 00:00:00 -0800
</pubDate>
</item>
</channel>
</rss>
