<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://simplelambda.com' rel='self' type='application/rss+xml'/>
<title>
Î»ambda Closure
</title>
<link>
http://simplelambda.com
</link>
<description>
This blog is awesome
</description>
<lastBuildDate>
Tue, 08 Mar 2016 21:54:40 -0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://simplelambda.com/posts/2016-03-08-elm-game-of-life.html
</guid>
<link>
http://simplelambda.com/posts/2016-03-08-elm-game-of-life.html
</link>
<title>
Elm - Conway's Game of Life - Functional Programming in the browser
</title>
<description>
&lt;p&gt;This is the second post of my series describing functional programming abstraction in the browser. Elm is a relatively new programming language. Elm code compiles to JS, HTML and CSS. It embraces Reactive Programming in a Functional Programming mindset.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;elm&amp;#95;language&quot;&gt;&lt;/a&gt;Elm Language&lt;/h2&gt;&lt;p&gt;To be honest, I am pretty excited about Elm! It looks very promising. Elm's syntax is very close to Haskell's syntax. So if you happen to know Haskell you will start writing Elm code in no time.&lt;/p&gt;&lt;p&gt;Here is a list of core features that makes it interesting imo:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Purely Functional&lt;ul&gt;&lt;li&gt;Higher order functions&lt;/li&gt;&lt;li&gt;Currying&lt;/li&gt;&lt;li&gt;Laziness&lt;/li&gt;&lt;li&gt;Immutable Data Structures&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Small core language&lt;ul&gt;&lt;li&gt;The Elm core packages are very simple and small. A couple of hours only is needed to dive into it. Not as small as a lisp though but still very small.&lt;/li&gt;&lt;li&gt;The Elm source code is amazingly well writen (in Haskell). It is available on Github.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Expressive language&lt;/li&gt;&lt;li&gt;Amazing Type System&lt;ul&gt;&lt;li&gt;Safety: No runtime exceptions&lt;/li&gt;&lt;li&gt;Algebraic Data Types&lt;/li&gt;&lt;li&gt;Parametricity&lt;/li&gt;&lt;li&gt;Hindley Milner&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Reactive Programming&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;elm&amp;#95;architecture&quot;&gt;&lt;/a&gt;Elm Architecture&lt;/h2&gt;&lt;p&gt;The Elm Architecture is a simple yet sophisticated pattern for writing infinitely nestable components. This is something anyone would like to have for modularity, code reuse and testing.&lt;/p&gt;&lt;p&gt;The architecture of an Elm program is the composition of 3 separated parts:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;: Data Structure (usually a combination of algebraic data types) that describes the state of the program&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Update&lt;/strong&gt;: Reducer functions from a model to a new model&lt;/li&gt;&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;: pure function of the model + event handlers&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I tend to see it as a proper implementation of the MVC pattern that is commonly found in other frameworks. The business logic and data are completely separated from the view code.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;conway's&amp;#95;game&amp;#95;of&amp;#95;life&quot;&gt;&lt;/a&gt;Conway's Game of Life&lt;/h2&gt;&lt;p&gt;I decided to code a little Elm program for Conway's Game of Life to get a better understanding of Elm. My code is available on &lt;a href='https://github.com/Chouffe/elm-game-of-life'&gt;github&lt;/a&gt; as always.&lt;/p&gt;&lt;p&gt;Let's first consider how it works&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There is a board containing alive and dead cells&lt;/li&gt;&lt;li&gt;A particular cell on the board will die or live according to Conway's rules&lt;/li&gt;&lt;li&gt;Time is perceived as a sequence of transitions between board states&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here are all the actions I wanted to enable:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Changing a cell from dead to alive by clicking on the board&lt;/li&gt;&lt;li&gt;Simulating a time change by clicking a &lt;em&gt;Next&lt;/em&gt; button&lt;/li&gt;&lt;li&gt;Loading predefined boards to quickly visualize some interesting shapes in Conway's Game of Life&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Disclaimer: I am an Elm beginner (This is actually my first Elm program). Please forgive my bad coding style if you are more experienced. I would love to know the proper ways to achieve some data transformation. Feel free to reach out.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;modeling&amp;#95;state&quot;&gt;&lt;/a&gt;Modeling State&lt;/h3&gt;&lt;p&gt;I model the game as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Cell: Dead/Alive are modeled with booleans&lt;/li&gt;&lt;li&gt;Board: 2 dimensional array of Cells&lt;/li&gt;&lt;li&gt;Position: a position on the board is a hashmap with the keys &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt;. I could be using a tuple for that but I wanted to play with the hashmap datastructure.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;type alias Position = { x : Int, y : Int }

type alias Model = A.Array &amp;#40;A.Array Bool&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;manipulating&amp;#95;state&quot;&gt;&lt;/a&gt;Manipulating State&lt;/h3&gt;Maybe I am reinventing the wheel but I need some helper functions to manipulate my states.&lt;h4&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h4&gt;I need to be able to tell the width and height of a board.&lt;pre&gt;&lt;code&gt;height : Model -&amp;gt; Int
height model = A.length model

width : Model -&amp;gt; Int
width model =
    case A.get 0 model of
        Nothing -&amp;gt; 0
        Just row -&amp;gt; A.length row
&lt;/code&gt;&lt;/pre&gt;I also need to update a Cell value on the board given a Position.&lt;pre&gt;&lt;code&gt;getIn : A.Array &amp;#40;A.Array a&amp;#41; -&amp;gt; Position -&amp;gt; Maybe a
getIn model position =
    case A.get position.x model of
        Nothing -&amp;gt; Nothing
        Just row -&amp;gt; A.get position.y row

assocIn : A.Array &amp;#40;A.Array a&amp;#41; -&amp;gt; Position -&amp;gt; a -&amp;gt; A.Array &amp;#40;A.Array a&amp;#41;
assocIn model position x =
    case A.get position.x model of
        Nothing -&amp;gt; model
        Just row -&amp;gt;
            let updatedRow = A.set position.y x row
            in
                A.set position.x updatedRow model

updateIn : A.Array &amp;#40;A.Array a&amp;#41; -&amp;gt; Position -&amp;gt; &amp;#40;a -&amp;gt; a&amp;#41; -&amp;gt; A.Array &amp;#40;A.Array a&amp;#41;
updateIn model position f =
    case getIn model position of
        Nothing -&amp;gt; model
        Just b -&amp;gt; assocIn model position &amp;#40;f b&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I found the Array core package lacking some important functions. I reimplemented some functions to manipulate 2d arrays (Clojure like functions).&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;positions&quot;&gt;&lt;/a&gt;Positions&lt;/h4&gt;I need a constructor for creating Position values&lt;pre&gt;&lt;code&gt;position : Int -&amp;gt; Int -&amp;gt; Position
position i j = { x = i, y = j }

positions : Model -&amp;gt; List Position
positions model =
    let w = width model
        h = height model
    in List.concatMap &amp;#40;\i -&amp;gt; &amp;#40;List.map &amp;#40;position i&amp;#41; &amp;#40;range 0 w&amp;#41;&amp;#41;&amp;#41; &amp;#40;range 0 h&amp;#41;

&lt;/code&gt;&lt;/pre&gt;I wish Elm had list comprehensions or at least monadic operations to operate on Lists, Arrays and Maybe values.Here I had to basically reimplement the Haskell &gt;&gt;= for lists. I am sure there is a rationale for not having them in Elm. I have not figured it out yet though ;)&lt;pre&gt;&lt;code&gt;List.concatMap &amp;#40;\i -&amp;gt; &amp;#40;List.map &amp;#40;position i&amp;#41; &amp;#40;range 0 w&amp;#41;&amp;#41;&amp;#41; &amp;#40;range 0 h&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;update&quot;&gt;&lt;/a&gt;Update&lt;/h3&gt;&lt;p&gt;The update part of the Elm program is usually really short and can be seen as a FSM (Finite State Machine) with Actions and Models. The Action type is an union type that describes the possible actions that can be performed on the model. The &lt;code&gt;update&lt;/code&gt; function is a reducer function from actions to models. This pattern can be found in re-frame (ClojureScript) and React as well.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;type Action = Next
            | LoadBoard Model
            | ToggleValue Position

update : Action -&amp;gt; Model -&amp;gt; Model
update action model =
    case action of
        Next -&amp;gt; next model
        LoadBoard model -&amp;gt; model
        ToggleValue pos -&amp;gt; updateIn model pos not
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;business&amp;#95;logic&amp;#95;(update&amp;#95;logic)&quot;&gt;&lt;/a&gt;Business Logic (Update Logic)&lt;/h4&gt;&lt;p&gt;All the logic is composition of pure functions and is located in one place. Here is the business logic needed to transition from one board state to the next.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;isValid : Model -&amp;gt; Position -&amp;gt; Bool
isValid model position =
    let w = width model
        h = height model
        x = position.x
        y = position.y
    in
        if x &amp;gt;= h then False
        else if y &amp;gt;= w then False
        else if x &amp;lt; 0 then False
        else if y &amp;lt; 0 then False
        else True

neighbors : Model -&amp;gt; Position -&amp;gt; List Position
neighbors model pos =
    let w = width model
        h = height model
        x = pos.x
        y = pos.y
    in
        &amp;#91; &amp;#40;x + 1, y&amp;#41;, &amp;#40;x + 1, y + 1&amp;#41;, &amp;#40;x + 1, y - 1&amp;#41;
        , &amp;#40;x , y + 1&amp;#41;, &amp;#40;x, y - 1&amp;#41;
        , &amp;#40;x - 1, y&amp;#41;, &amp;#40;x - 1, y + 1&amp;#41;, &amp;#40;x - 1, y - 1&amp;#41;
        &amp;#93;
            |&amp;gt; List.map &amp;#40;\&amp;#40;i, j&amp;#41; -&amp;gt; position i j&amp;#41;
            |&amp;gt; List.filter &amp;#40;isValid model&amp;#41;

isDead : Model -&amp;gt; Position -&amp;gt; Bool
isDead model position =
    case getIn model position of
        Nothing -&amp;gt; False
        Just b -&amp;gt; not b

isAlive : Model -&amp;gt; Position -&amp;gt; Bool
isAlive model = not &amp;lt;&amp;lt; isDead model

rules : Bool -&amp;gt; Int -&amp;gt; Int -&amp;gt; Bool
rules self deadCellCount aliveCellCount =
    if self &amp;amp;&amp;amp; aliveCellCount &amp;lt; 2 then False
    else if self &amp;amp;&amp;amp; aliveCellCount &amp;gt;= 2 &amp;amp;&amp;amp; aliveCellCount &amp;lt;= 3 then True
    else if not self &amp;amp;&amp;amp; aliveCellCount == 3 then True
    else False

next : Model -&amp;gt; Model
next model =
    positions model
        |&amp;gt; List.foldl &amp;#40;\position m -&amp;gt; assocIn m position &amp;#40;nextCellState model position&amp;#41;&amp;#41; model

nextCellState : Model -&amp;gt; Position -&amp;gt; Bool
nextCellState model position =
    let neighbs = neighbors model position
        deadCellCount = List.length &amp;#40;List.filter &amp;#40;isDead model&amp;#41; neighbs&amp;#41;
        aliveCellCount = List.length &amp;#40;List.filter &amp;#40;isAlive model&amp;#41; neighbs&amp;#41;
    in case &amp;#40;getIn model position&amp;#41; of
        Nothing -&amp;gt; False
        Just self -&amp;gt; rules self deadCellCount aliveCellCount
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;view&quot;&gt;&lt;/a&gt;View&lt;/h3&gt;The last missing piece of our Elm program is the view. Which is a pure function of the model.&lt;pre&gt;&lt;code&gt;viewCell : Signal.Address Action -&amp;gt; Position -&amp;gt; Int -&amp;gt; Bool -&amp;gt; Html
viewCell address position width b =
    div &amp;#91; viewCellStyle width b
        , onClick address &amp;#40;ToggleValue position&amp;#41;
        , class &amp;#40;&amp;quot;cell-item&amp;quot; ++ &amp;quot; &amp;quot; ++ &amp;#40;if b then &amp;quot;cell-alive&amp;quot; else &amp;quot;cell-dead&amp;quot;&amp;#41;&amp;#41;
        &amp;#93; &amp;#91;&amp;#93;

selectBoardView : Signal.Address Action -&amp;gt; List &amp;#40;String, Model&amp;#41; -&amp;gt; Html
selectBoardView address models =
    div &amp;#91; class &amp;quot;btn-group pull-right&amp;quot; &amp;#93;
        &amp;#40;List.map &amp;#40;\&amp;#40;s, m&amp;#41; -&amp;gt; div &amp;#91; class &amp;quot;btn btn-default&amp;quot;
                                  , onClick address &amp;#40;LoadBoard m&amp;#41; &amp;#93;
                                  &amp;#91; text s &amp;#93;&amp;#41; models&amp;#41;

view : Signal.Address Action -&amp;gt; Model -&amp;gt; Html
view address model =
    let w = width model
    in
        div &amp;#91;class &amp;quot;game-container&amp;quot; &amp;#93;
            &amp;#91; css &amp;quot;game.css&amp;quot;
            , css &amp;quot;//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css&amp;quot;
            , div &amp;#91; class &amp;quot;button-container&amp;quot; &amp;#93;
                  &amp;#91;div &amp;#91; class &amp;quot;btn btn-default&amp;quot;
                       , onClick address Next&amp;#93;
                        &amp;#91;text &amp;quot;Next&amp;quot;&amp;#93;
                  , selectBoardView address boards
                &amp;#93;
            , div &amp;#91; class &amp;quot;board-container&amp;quot; &amp;#93;
                  &amp;#40;List.indexedMap &amp;#40;\k b -&amp;gt; viewCell address &amp;#40;intToPosition k w&amp;#41; w b&amp;#41; &amp;#40;A.toList &amp;#40;concat model&amp;#41;&amp;#41;&amp;#41;
            &amp;#93;

viewCellStyle : Int -&amp;gt; Bool -&amp;gt; Attribute
viewCellStyle width b =
    style &amp;#91; &amp;#40;&amp;quot;flex-basis&amp;quot;, toString &amp;#40;100.0 / &amp;#40;toFloat width&amp;#41;&amp;#41; ++ &amp;quot;%&amp;quot;&amp;#41; &amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All the view functions are purely declarative. We never need to take care of DOM mutations because Elm takes care of that for us.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;entrypoint&quot;&gt;&lt;/a&gt;Entrypoint&lt;/h3&gt;The main entrypoint of our program is the following &lt;code&gt;main&lt;/code&gt; function:&lt;pre&gt;&lt;code&gt;main =
  start
    { model = pulsar
    , update = update
    , view = view
    }

pulsar = A.fromList &amp;#91; A.fromList &amp;#91; False, False, False, False, False, False, False, False, False, False, False, False, False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, True,  True,  True,  False, False, False, True,  True,  True,  False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, False, False, False, False, False, False, False, False, False, False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, True,  True,  True,  False, False, False, True,  True,  True,  False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, False, False, False, False, False, False, False, False, False, False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, True,  True,  True,  False, False, False, True,  True,  True,  False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, True,  False, False, False, False, True,  False, True,  False, False, False, False, True,  False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, False, False, False, False, False, False, False, False, False, False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, True,  True,  True,  False, False, False, True,  True,  True,  False, False, False &amp;#93;
                    , A.fromList &amp;#91; False, False, False, False, False, False, False, False, False, False, False, False, False, False, False &amp;#93;
                    &amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;result&quot;&gt;&lt;/a&gt;Result&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/img/gameoflife/gameoflife.png&quot; alt=&quot;Conway's Game of Life in Elm&quot; /&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;&lt;/p&gt;&lt;p&gt;I really enjoyed learning a bit of Elm and coding that small application. The learning curve is really smooth and if you happen to know Haskell you can start coding in Elm right away. Frontend is getting fun again thanks to Functional Reactive Programming. We should all be thankful to Elm since it has paved he way to bringing awesomeness to the frontend (Redux, React, re-frame...).&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;pros&quot;&gt;&lt;/a&gt;Pros&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Type System&lt;/strong&gt;: it speeds up development with its awesome error messages and strong guarantees (no runtime exceptions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Persistent Data Structures&lt;/strong&gt;: all the most common datastructures are available in Elm core and are persistent (functional):&lt;ul&gt;&lt;li&gt;Records (Hashmap)&lt;/li&gt;&lt;li&gt;Lists&lt;/li&gt;&lt;li&gt;Arrays&lt;/li&gt;&lt;li&gt;Sets&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Fun&lt;/strong&gt;: Elm is really fun to use (do not underestimate this because this is the main feature of Ruby).&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Elm Architecture&lt;/strong&gt;: so simple but powerful way to compose and reuse pure functional code.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Tooling&lt;/strong&gt;: amazing tooling to recompile from the browser and hot swap code&lt;ul&gt;&lt;li&gt;Time traveling debugger&lt;/li&gt;&lt;li&gt;Hot code swapping&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;a name=&quot;cons&quot;&gt;&lt;/a&gt;Cons&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Lack of adhoc polymorphism&lt;/strong&gt; (Haskell Typeclasses/Clojure protocols...): it is painful to use different functions (eg. List.map, Array.map, Set.map, ...) to perform similar operations on different datastructures. I think this is a even a deal breaker not to incorporate this in Elm.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Javascript interop&lt;/strong&gt;: it seems like a lot of ceremony to interop with javascipt libraries. You need to use &lt;code&gt;ports&lt;/code&gt; and send messages back and forth. I do not see a simple solution to call javascript code directly from Elm code without using ports though.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Very young language&lt;/strong&gt;: The Elm community seems very excited and is growing all the time. Some fundamental libraries are not there yet and it may take a long time to get there.&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 08 Mar 2016 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
http://simplelambda.com/posts/2016-03-03-mandelbrot-set.html
</guid>
<link>
http://simplelambda.com/posts/2016-03-03-mandelbrot-set.html
</link>
<title>
Fractals - Exploration of the Mandelbrot Set with ClojureScript and React
</title>
<description>
&lt;p&gt;A fractal is a mathematical object that exhibits a pattern that repeats itself at every scale. They are very interesting mathematical concepts because they differ from regular geometrical figures. How does one measure the length a fractal curve? The Mandelbrot Set is a closed area of the complex plane but still, its perimeter is not a finite number. Sophisticated structures arise from very simple rules!&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/2/21/Mandel_zoom_00_mandelbrot_set.jpg&quot; alt=&quot;Mandelbrot Set&quot; /&gt;&lt;/p&gt;&lt;p&gt;The goal of this post is to see how we can build a simple UI tool to visualize the Mandelbrot Set.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/ce/Mandelbrot_zoom.gif&quot; alt=&quot;Mandelbrot Repeating Pattern&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;mandelbrot&amp;#95;set&quot;&gt;&lt;/a&gt;Mandelbrot Set&lt;/h2&gt;&lt;p&gt;The &lt;strong&gt;Mandelbrot Set&lt;/strong&gt; is the set of complex numbers such that the function f(z) = z&lt;sup&gt;2&lt;/sup&gt; + c does not diverge when iterated.&lt;/p&gt;&lt;p&gt;A practical test is often to iterate n times and to check whether the value remains bouded (eg. &lt; 2)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;f(z)&lt;/li&gt;&lt;li&gt;f(f(z))&lt;/li&gt;&lt;li&gt;f(f(f(z))) ...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This fractal is particularly interesting because it is one of the best-known examples of mathematical visualization or mathematical art. It has also some real world applications in complex dynamics.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;modeling&amp;#95;complex&amp;#95;numbers&quot;&gt;&lt;/a&gt;Modeling complex numbers&lt;/h2&gt;&lt;p&gt;The Mandelbrot Set is a subset of the Complex plane. We need a way to represent &lt;a href='https://en.wikipedia.org/wiki/Complex_number'&gt;complex numbers&lt;/a&gt; in Clojure. As a reminder, complex numbers are numbers that can be expressed in the form a + b&lt;em&gt;i&lt;/em&gt; where a and b are real numbers and &lt;em&gt;i&lt;/em&gt; is the imaginary unit.&lt;/p&gt;&lt;p&gt;I will not get really fancy implementing the complex operations required to generate the Mandelbrot Set. I may implement a robust library for complex numbers in the future but for now, we will just go with 3 operations:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;add: adds two complex numbers&lt;/li&gt;&lt;li&gt;mult: multiplies two complex numbers&lt;/li&gt;&lt;li&gt;abs: norm of a complex number&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Also, there are two common ways to represent complex numbers. The first one is a tuple of imaginary part (Im) and real part (Re). The second one uses the distance from O (origin in the Complex plane) and the angle of OP and the x-axis (which is known as the argument of the complex number). Sometimes, operations can be performed more efficiently in one representation or the other. For now, I will only provide one representation for the complex numbers:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns mandelbrot.complex&amp;#41;

&amp;#40;defn z &amp;#91;x y&amp;#93; &amp;#91;x y&amp;#93;&amp;#41;

&amp;#40;defn add &amp;#91;z1 z2&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x1 y1&amp;#93; z1
        &amp;#91;x2 y2&amp;#93; z2&amp;#93;
    &amp;#91;&amp;#40;+ x1 x2&amp;#41; &amp;#40;+ y1 y2&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn mult &amp;#91;z1 z2&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x1 y1&amp;#93; z1
        &amp;#91;x2 y2&amp;#93; z2&amp;#93;
    &amp;#91;&amp;#40;- &amp;#40;&amp;#42; x1 x2&amp;#41;
        &amp;#40;&amp;#42; y1 y2&amp;#41;&amp;#41;
     &amp;#40;+ &amp;#40;&amp;#42; y1 x2&amp;#41;
        &amp;#40;&amp;#42; y2 x1&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn abs &amp;#91;z&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x y&amp;#93; z&amp;#93;
    &amp;#40;#?&amp;#40;:clj Math/sqrt :cljs js/Math.sqrt&amp;#41; &amp;#40;+ &amp;#40;&amp;#42; x x&amp;#41; &amp;#40;&amp;#42; y y&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;set&amp;#95;generation&quot;&gt;&lt;/a&gt;Set generation&lt;/h2&gt;&lt;p&gt;We only need a function &lt;code&gt;mandelbrot?&lt;/code&gt; that takes in a complex number &lt;code&gt;z&lt;/code&gt; and returns a boolean. &lt;code&gt;z&lt;/code&gt; is in the set if and only if it does not diverge when repeatedly applying the function f.&lt;/p&gt;&lt;p&gt;f(u) = u&lt;sup&gt;2&lt;/sup&gt; + z&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn mandelbrot? &amp;#91;z&amp;#93;
  &amp;#40;let &amp;#91;max-iter 20&amp;#93;
    &amp;#40;loop &amp;#91;k 1
           m &amp;#40;iterate #&amp;#40;c/add z &amp;#40;c/mult % %&amp;#41;&amp;#41; &amp;#40;c/z 0 0&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;if &amp;#40;and &amp;#40;&amp;gt; max-iter k&amp;#41; &amp;#40;&amp;lt; &amp;#40;c/abs &amp;#40;first m&amp;#41;&amp;#41; 2&amp;#41;&amp;#41;
        &amp;#40;recur &amp;#40;inc k&amp;#41; &amp;#40;rest m&amp;#41;&amp;#41;
        &amp;#40;= max-iter k&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can already generate the mandelbrot set with this &lt;code&gt;mandelbrot?&lt;/code&gt; function. In order to make it look nicer, we can return the number of iterations needed to see that it diverges. We will then be able to display a gradient of colors instead of only 2 colors.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn &amp;#94;:private mandelbrot-n-iter-aux
  &amp;#91;z u n-max k&amp;#93;
  &amp;#40;cond
    &amp;#40;&amp;gt; &amp;#40;c/abs u&amp;#41; 2&amp;#41; &amp;#91;false k&amp;#93;
    &amp;#40;&amp;gt;= k n-max&amp;#41; &amp;#91;true k&amp;#93;
    :else &amp;#40;recur z &amp;#40;c/add z &amp;#40;c/mult u u&amp;#41;&amp;#41; n-max &amp;#40;inc k&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private mandelbrot-n-iter &amp;#91;z&amp;#93;
  &amp;#40;mandelbrot-n-iter-aux z &amp;#40;c/z 0 0&amp;#41; 20 1&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private mandelbrot-value &amp;#91;range-x range-y&amp;#93;
  &amp;#40;for &amp;#91;y range-y
        x range-x&amp;#93;
    &amp;#40;let &amp;#91;&amp;#91;in-set? k&amp;#93; &amp;#40;mandelbrot-n-iter &amp;#40;c/z x y&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;if in-set? 0 k&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;I built a simple visualization tool with ClojureScript, React, re-frame and the mandelbrot functions discussed above. The colors can be changed by sliding the ranges, zooming is enabled and clicking on the fractal moves it accordingly.&lt;/p&gt;&lt;p&gt;&lt;link href=&quot;/posts/css/mandelbrot.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;mandelbrot&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/mandelbrot.js&quot;&gt;&lt;/script&gt; &lt;script&gt;mandelbrot.core.init();&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The code is fully available on &lt;a href='https://github.com/Chouffe/fractals'&gt;my github&lt;/a&gt;. Feel free to explore the code and explore your own fractal objects.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;&lt;p&gt;The Mandelbrot Set is a very simple yet sophisticated mathematical object that derives from very simple rules. I'd like to generate other fractal objects (Julia, Sierpinski Gasket) in a next project.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 03 Mar 2016 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
http://simplelambda.com/posts/2016-03-01-autocomplete.html
</guid>
<link>
http://simplelambda.com/posts/2016-03-01-autocomplete.html
</link>
<title>
Autocomplete - Trie Datastructure in Clojure and ClojureScript
</title>
<description>
&lt;p&gt;A &lt;a href='https://en.wikipedia.org/wiki/Trie'&gt;trie&lt;/a&gt; is a powerful datastructure often used for dictionary representation. The goal of this post is to implement a trie in Clojure and ClojureScript. Then we will build an autocomplete system.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;trie&quot;&gt;&lt;/a&gt;Trie&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;A trie or prefix tree (as they can be searched by prefixes) is an ordered datastructure that is used to store an associative array where the keys are ususally strings.&lt;/li&gt;&lt;li&gt;All the descendants of a node have a common prefix of the string associated with that node.&lt;/li&gt;&lt;li&gt;The root node is the empty string&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/600px-Trie_example.svg.png&quot; alt=&quot;Trie Datastructure&quot; /&gt;&lt;/li&gt;&lt;li&gt;A prefix tree allows for quick search, insert and delete operations O(log k) where k is the length of the prefix string&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;&lt;link href=&quot;/posts/css/autocomplete.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;autocomplete-app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/autocomplete.js&quot;&gt;&lt;/script&gt; &lt;script&gt;autocomplete.core.init();&lt;/script&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The left input field allows you to add strings in the trie&lt;/li&gt;&lt;li&gt;the right input field performs autocompletes&lt;/li&gt;&lt;li&gt;The trie is represented as nested list for visualization&lt;/li&gt;&lt;li&gt;Some preset lists of strings can be loaded by clicking on the buttons &lt;code&gt;Reset&lt;/code&gt;, &lt;code&gt;Small Alphabet&lt;/code&gt;, &lt;code&gt;Countries&lt;/code&gt; or &lt;code&gt;Languages&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;The colors of the elements in the trie change if they match the prefix-string&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h2&gt;&lt;p&gt;You can find my trie implementation on &lt;a href='https://github.com/Chouffe/clj-trie'&gt;github&lt;/a&gt; and &lt;a href='https://clojars.org/trie'&gt;clojars&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;datastructure&quot;&gt;&lt;/a&gt;Datastructure&lt;/h3&gt;&lt;p&gt;Each node of the trie will contain the following keys:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: the current prefix string at that node, eg &quot;te&quot;, &quot;in&quot;...&lt;/li&gt;&lt;li&gt;&lt;strong&gt;children&lt;/strong&gt;: a hashmap from char to node&lt;/li&gt;&lt;li&gt;&lt;strong&gt;key&lt;/strong&gt;: flag to say if the value of that node is in the dictionary&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The empty trie is then&lt;pre&gt;&lt;code&gt;&amp;#40;defn- make-empty-trie
  &amp;quot;Creates an empty trie with empty lexicon.&amp;quot;
  &amp;#91;&amp;#93;
  {:value &amp;quot;&amp;quot;}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;operations&quot;&gt;&lt;/a&gt;Operations&lt;/h3&gt;&lt;h4&gt;&lt;a name=&quot;conj&amp;#95;-&amp;#95;adding&amp;#95;to&amp;#95;a&amp;#95;trie&quot;&gt;&lt;/a&gt;Conj - Adding to a trie&lt;/h4&gt;When adding a string to a trie, we need to perform the following:&lt;ul&gt;&lt;li&gt;Go down the tree following the characters of the string&lt;/li&gt;&lt;li&gt;Create nodes (if they do not exist yet) unitl the last character of the string is reached&lt;/li&gt;&lt;li&gt;Add/Update the node with a flag to say that this word (path from root to the node) has been added to the trie&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- conj-trie
  &amp;#91;{:keys &amp;#91;value children&amp;#93; :as trie} &amp;#91;c &amp;amp; cs :as string&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;ch &amp;#40;str c&amp;#41;&amp;#93;
    &amp;#40;cond
      ; A leaf is reached and last letter in string
      &amp;#40;and &amp;#40;not &amp;#40;get children ch&amp;#41;&amp;#41; &amp;#40;not &amp;#40;seq cs&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children &amp;#40;str c&amp;#41;&amp;#93; {:value &amp;#40;str value c&amp;#41; :key &amp;#40;gensym&amp;#41;}&amp;#41;

      ; A leaf is reached and still some letters
      &amp;#40;and &amp;#40;not &amp;#40;get children ch&amp;#41;&amp;#41; &amp;#40;seq cs&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children ch&amp;#93; &amp;#40;conj-trie {:value &amp;#40;str value c&amp;#41;} cs&amp;#41;&amp;#41;

      ; No more letters but already present in the trie
      &amp;#40;and &amp;#40;get children ch&amp;#41; &amp;#40;not &amp;#40;seq cs&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;assoc-in trie &amp;#91;:children ch :key&amp;#93; &amp;#40;gensym&amp;#41;&amp;#41;

      ; Already in trie and still letters
      &amp;#40;and &amp;#40;get children ch&amp;#41; &amp;#40;seq cs&amp;#41;&amp;#41;
      &amp;#40;update-in trie &amp;#91;:children ch&amp;#93; conj-trie cs&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then adding a set of strings is just a fold over the collection&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- into-trie
  &amp;#91;trie coll&amp;#93;
  &amp;#40;reduce conj-trie trie coll&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the Clojure Datastructure that represents the trie&lt;pre&gt;&lt;code&gt;{:value &amp;quot;&amp;quot;,
 :children
 {&amp;quot;t&amp;quot;
  {:value &amp;quot;t&amp;quot;,
   :children
   {&amp;quot;e&amp;quot;
    {:value &amp;quot;te&amp;quot;,
     :children
     {&amp;quot;a&amp;quot; {:value &amp;quot;tea&amp;quot;, :key G&amp;#95;&amp;#95;22475},
      &amp;quot;d&amp;quot; {:value &amp;quot;ted&amp;quot;, :key G&amp;#95;&amp;#95;22477},
      &amp;quot;n&amp;quot; {:value &amp;quot;ten&amp;quot;, :key G&amp;#95;&amp;#95;22478}}},
    &amp;quot;o&amp;quot; {:value &amp;quot;to&amp;quot;, :key G&amp;#95;&amp;#95;22476}}},
  &amp;quot;a&amp;quot; {:value &amp;quot;a&amp;quot;, :key G&amp;#95;&amp;#95;22479},
  &amp;quot;i&amp;quot;
  {:value &amp;quot;i&amp;quot;,
   :key G&amp;#95;&amp;#95;22480,
   :children
   {&amp;quot;n&amp;quot;
    {:value &amp;quot;in&amp;quot;,
     :key G&amp;#95;&amp;#95;22481,
     :children {&amp;quot;n&amp;quot; {:value &amp;quot;inn&amp;quot;, :key G&amp;#95;&amp;#95;22482}}}}}}}
 &lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;search&quot;&gt;&lt;/a&gt;Search&lt;/h3&gt;To search into the trie (autocomplete given a prefix string), we only need to go down the trie following the prefix string characters and then collect the elements in this subtree.&lt;h4&gt;&lt;a name=&quot;apply-trie&quot;&gt;&lt;/a&gt;apply-trie&lt;/h4&gt;&lt;/p&gt;&lt;p&gt;The &lt;code&gt;apply-trie&lt;/code&gt; function goes down the trie following the characters and then call the funtion &lt;code&gt;trie-&amp;gt;seq&lt;/code&gt; on this subtree.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- apply-trie
  &amp;#91;{:keys &amp;#91;value key children&amp;#93; :as trie} &amp;#91;c &amp;amp; cs :as string&amp;#93;&amp;#93;
  &amp;#40;cond
    &amp;#40;not &amp;#40;seq string&amp;#41;&amp;#41;           &amp;#40;trie-&amp;gt;seq trie&amp;#41;
    &amp;#40;not &amp;#40;get children &amp;#40;str c&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93;
    :else                        &amp;#40;recur &amp;#40;get children &amp;#40;str c&amp;#41;&amp;#41; cs&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;trie-&gt;seq&quot;&gt;&lt;/a&gt;trie-&gt;seq&lt;/h4&gt;This function is just a DFS on the given trie and returns the element in order.&lt;pre&gt;&lt;code&gt;&amp;#40;defn- trie-&amp;gt;seq
  &amp;quot;Returns all the elements inserted in trie as a sequence.&amp;quot;
  &amp;#91;{:keys &amp;#91;value children key&amp;#93; :as trie}&amp;#93;
  &amp;#40;loop &amp;#91;stack &amp;#91;trie&amp;#93;
         words &amp;#91;&amp;#93;&amp;#93;
    &amp;#40;if &amp;#40;not &amp;#40;seq stack&amp;#41;&amp;#41;
      &amp;#40;seq words&amp;#41;
      &amp;#40;let &amp;#91;{:keys &amp;#91;value children key&amp;#93;} &amp;#40;peek stack&amp;#41;&amp;#93;
        &amp;#40;recur &amp;#40;into &amp;#40;pop stack&amp;#41; &amp;#40;vals children&amp;#41;&amp;#41;
               &amp;#40;if key &amp;#40;conj words value&amp;#41; words&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;protocols&amp;#95;and&amp;#95;interfaces&quot;&gt;&lt;/a&gt;Protocols and Interfaces&lt;/h3&gt;&lt;h4&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h4&gt;To make it feel like a built-in clojure Datastructure, we can define a Trie type that will implement some common clojure interfaces&lt;ul&gt;&lt;li&gt;IPersistentCollection&lt;/li&gt;&lt;li&gt;ILookup&lt;/li&gt;&lt;li&gt;IFn&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The goal is to be able to do the following&lt;/p&gt;&lt;pre&gt;&lt;code&gt;;; Creating a trie
&amp;#40;def autocomplete &amp;#40;trie &amp;#91;&amp;quot;doo&amp;quot; &amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;&amp;#41;&amp;#41;

;; Autocomplete given a prefix-string
&amp;#40;autocomplete &amp;quot;ba&amp;quot;&amp;#41; =&amp;gt; &amp;#91;&amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;

;; Adding to the trie
&amp;#40;&amp;#40;conj autocomplete &amp;quot;baf&amp;quot;&amp;#41; &amp;quot;ba&amp;quot;&amp;#41; =&amp;gt; &amp;#91;&amp;quot;baf&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h4&gt;Clojure implementation&lt;pre&gt;&lt;code&gt;&amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      clojure.lang.ILookup
      &amp;#40;valAt &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;valAt &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      clojure.lang.IPersistentCollection
      &amp;#40;seq &amp;#91;self&amp;#93;     &amp;#40;seq lexicon-set&amp;#41;&amp;#41;
      &amp;#40;cons &amp;#91;self o&amp;#93;  &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;empty &amp;#91;self&amp;#93;   &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
      &amp;#40;equiv &amp;#91;self o&amp;#93; &amp;#40;and &amp;#40;instance? Trie o&amp;#41; &amp;#40;= trie &amp;#40;.trie o&amp;#41;&amp;#41;&amp;#41;&amp;#41;

      clojure.lang.IFn
      &amp;#40;invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ClojureScript implementation&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      cljs.core/ILookup
      &amp;#40;-lookup &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;-lookup &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      cljs.core/ICollection
      &amp;#40;-conj &amp;#91;self o&amp;#93; &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;

      cljs.core/ICounted
      &amp;#40;-count &amp;#91;self&amp;#93; &amp;#40;count lexicon-set&amp;#41;&amp;#41;

      cljs.core/IEmptyableCollection
      &amp;#40;-empty &amp;#91;self&amp;#93; &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;

      cljs.core/IFn
      &amp;#40;-invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then the use of conditional readers and .cljc files allow us to make our trie work for Clojure and ClojureScript&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
#?&amp;#40;:clj
    &amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      clojure.lang.ILookup
      &amp;#40;valAt &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;valAt &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      clojure.lang.IPersistentCollection
      &amp;#40;seq &amp;#91;self&amp;#93;     &amp;#40;seq lexicon-set&amp;#41;&amp;#41;
      &amp;#40;cons &amp;#91;self o&amp;#93;  &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;empty &amp;#91;self&amp;#93;   &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
      &amp;#40;equiv &amp;#91;self o&amp;#93; &amp;#40;and &amp;#40;instance? Trie o&amp;#41; &amp;#40;= trie &amp;#40;.trie o&amp;#41;&amp;#41;&amp;#41;&amp;#41;

      clojure.lang.IFn
      &amp;#40;invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;&amp;#41;

#?&amp;#40;:cljs
    &amp;#40;deftype Trie &amp;#91;trie lexicon-set&amp;#93;

      cljs.core/ILookup
      &amp;#40;-lookup &amp;#91;self prefix-string&amp;#93; &amp;#40;get lexicon-set prefix-string&amp;#41;&amp;#41;
      &amp;#40;-lookup &amp;#91;self prefix-string default&amp;#93; &amp;#40;get lexicon-set prefix-string default&amp;#41;&amp;#41;

      cljs.core/ICollection
      &amp;#40;-conj &amp;#91;self o&amp;#93; &amp;#40;Trie. &amp;#40;conj-trie trie o&amp;#41; &amp;#40;conj lexicon-set o&amp;#41;&amp;#41;&amp;#41;

      cljs.core/ICounted
      &amp;#40;-count &amp;#91;self&amp;#93; &amp;#40;count lexicon-set&amp;#41;&amp;#41;

      cljs.core/IEmptyableCollection
      &amp;#40;-empty &amp;#91;self&amp;#93; &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;

      cljs.core/IFn
      &amp;#40;-invoke &amp;#91;self prefix-string&amp;#93;
        &amp;#40;let &amp;#91;completions &amp;#40;apply-trie trie prefix-string&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;seq completions&amp;#41; completions nil&amp;#41;&amp;#41;&amp;#41;

      Object
      &amp;#40;toString &amp;#91;self&amp;#93; &amp;#40;str trie&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, the main factory function is the &lt;code&gt;trie&lt;/code&gt; function&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn trie
  &amp;#40;&amp;#91;&amp;#93;     &amp;#40;Trie. &amp;#40;make-empty-trie&amp;#41; #{}&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;coll&amp;#93; &amp;#40;into &amp;#40;trie&amp;#41; &amp;#40;set &amp;#40;map s/lower-case coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;autocomplete&amp;#95;system&amp;#95;and&amp;#95;ui&quot;&gt;&lt;/a&gt;Autocomplete System and UI&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;I wanted to build a small &lt;a href='#demo'&gt;UI interface&lt;/a&gt; for my trie datastructure. The hard part was the trie visualization. I decided to use nested unordered lists to replicate the tree structure of the trie. I am still not sure convinced that is the best way to visualize a trie but it is good enough for the scope of this project.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;ClojureScript&lt;/li&gt;&lt;li&gt;re-frame (React + Reagent)&lt;/li&gt;&lt;li&gt;trie library developed before&lt;/li&gt;&lt;li&gt;Bootstrap for CSS style&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Actually, it took me more time to build the UI than to build and deploy the trie datastructure. It is hard to come up with good and simple UI components to help the reader understand how this datastructure works.&lt;/p&gt;&lt;p&gt;It is also on my &lt;a href='https://github.com/Chouffe/autocomplete'&gt;github&lt;/a&gt; if you want to take a look at the code :)&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 01 Mar 2016 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</guid>
<link>
http://simplelambda.com/posts/2016-02-29-snake-clojurescript-reagent.html
</link>
<title>
Snake the game - A Functional Programming Style tutorial for ClojureScript and Reagent
</title>
<description>
&lt;p&gt;Functional Programming is finally getting broadly used in the frontend! This is fantastic news! I have been programming in Clojure/ClojureScript for about 2 years. It seems to me that nothing can get quite close to it in terms of productivity and simplicity. So let's give it a try and see what else is out there.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h2&gt;I am starting this series of tutorials to compare different frontend abstractions to build modern real world applications. The goal is to provide the reader with some comparisons on different functional abstractions. I will focus on the following ones:&lt;ul&gt;&lt;li&gt;ClojureScript + Reagent&lt;/li&gt;&lt;li&gt;ClojureScript + Om&lt;/li&gt;&lt;li&gt;Elm&lt;/li&gt;&lt;li&gt;ReactJS&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;clojurescript&amp;#95;and&amp;#95;reagent&quot;&gt;&lt;/a&gt;ClojureScript and Reagent&lt;/h2&gt;The first post will focus on building a Snake Game in ClojureScript and Reagent, using the library re-frame. All the code is available on &lt;a href='https://github.com/Chouffe/snake'&gt;my github&lt;/a&gt;. Here is a demo of what we are about to build:&lt;p&gt;&lt;link href=&quot;/posts/css/snake.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;snake&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/posts/js/snake.js&quot;&gt;&lt;/script&gt; &lt;script&gt;snake.core.init();&lt;/script&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;setup&quot;&gt;&lt;/a&gt;Setup&lt;/h2&gt;To get started, just go read about &lt;a href='https://github.com/Day8/re-frame'&gt;re-frame&lt;/a&gt;. Then run the following lein command to start an re-frame app.&lt;blockquote&gt;&lt;p&gt; lein new re-frame &lt;project-name&gt; &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That should generate the following project dir:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.
âââ dev-resources
âââ figwheel&amp;#95;server.log
âââ project.clj
âââ README.md
âââ resources
âÂ Â  âââ public
âââ src
âÂ Â  âââ clj
âÂ Â  âââ cljs
âââ target
âÂ Â  âââ classes
âÂ Â  âââ figwheel&amp;#95;temp
âÂ Â  âââ stale
âââ test
    âââ cljs
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;modeling&amp;#95;state&quot;&gt;&lt;/a&gt;Modeling State&lt;/h2&gt;The following concepts are needed to properly model the Snake Game:&lt;ul&gt;&lt;li&gt;Board&lt;ul&gt;&lt;li&gt;width&lt;/li&gt;&lt;li&gt;height&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Snake&lt;ul&gt;&lt;li&gt;position&lt;/li&gt;&lt;li&gt;direction&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Apple position&lt;/li&gt;&lt;li&gt;Points&lt;/li&gt;&lt;li&gt;Is the game over?&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;The board is defined by a number of rows and columns.  simplest way to express it is to use a tuple of 2 elements &lt;code&gt;&amp;#91;width height&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-board &amp;#91;&amp;#93; &amp;#91;35 25&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;snake&quot;&gt;&lt;/a&gt;Snake&lt;/h3&gt;The snake is modeled with a direction in &lt;code&gt;#{:up :down :right :left}&lt;/code&gt; and a sequence of positions &lt;code&gt;&amp;#91;&amp;#91;x1 y1&amp;#93; &amp;#91;x2 y2&amp;#93;&amp;#93;&lt;/code&gt;.&lt;pre&gt;&lt;code&gt;&amp;#40;defn init-snake &amp;#91;&amp;#93;
  {:direction :right
   :body &amp;#91;&amp;#91;3 2&amp;#93; &amp;#91;2 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;0 2&amp;#93;&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;state&quot;&gt;&lt;/a&gt;State&lt;/h3&gt;The game state is the combination of all the above&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-free-position &amp;#91;board unavailable-positions&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; board
       positions
       &amp;#40;remove &amp;#40;set unavailable-positions&amp;#41;&amp;#41;
       rand-nth&amp;#41;&amp;#41;

&amp;#40;defn init-state &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;snake &amp;#40;init-snake&amp;#41;
        board &amp;#40;init-board&amp;#41;&amp;#93;
    {:running? true
     :board board
     :snake snake
     :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;
     :points 0}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;views&quot;&gt;&lt;/a&gt;The views&lt;/h2&gt;Reagent is a simple wrapper around React. We need to design our views as pure functions of the app-state. Re-frame achieves this by using FRP and subscribing to state changes.&lt;h3&gt;&lt;a name=&quot;score&quot;&gt;&lt;/a&gt;Score&lt;/h3&gt;The view function is very simple. It subscribes to the points value in the app-state.&lt;pre&gt;&lt;code&gt;&amp;#40;defn score &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;points &amp;#40;subscribe &amp;#91;:points&amp;#93;&amp;#41;&amp;#93;
    &amp;#91;:div.score &amp;quot;Score: &amp;quot; @points&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how a subscription gets registered:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;register-sub :points &amp;#40;fn &amp;#91;db&amp;#93; &amp;#40;reaction &amp;#40;:points @db&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;board&quot;&gt;&lt;/a&gt;Board&lt;/h3&gt;This view will be created with simple html elements. Canvas could have been used for that instead. Here, each cell of the board is a table cell with a given CSS class.&lt;pre&gt;&lt;code&gt;&amp;#40;defn board &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;board &amp;#40;subscribe &amp;#91;:board&amp;#93;&amp;#41;
        snake &amp;#40;subscribe &amp;#91;:snake&amp;#93;&amp;#41;
        food &amp;#40;subscribe &amp;#91;:food&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;&amp;#91;width height&amp;#93; @board
            {:keys &amp;#91;body&amp;#93;} @snake&amp;#93;
        &amp;#40;into &amp;#91;:table.stage&amp;#93;
              &amp;#40;for &amp;#91;y &amp;#40;range height&amp;#41;&amp;#93;
                &amp;#40;into &amp;#91;:tr {:key y}&amp;#93;
                      &amp;#40;mapv &amp;#40;fn &amp;#91;x&amp;#93; &amp;#91;:td {:key &amp;#40;str x &amp;quot;.&amp;quot; y&amp;#41;
                                          :class &amp;#40;cell-class &amp;#91;x y&amp;#93; @food &amp;#40;set body&amp;#41;&amp;#41;}&amp;#93;&amp;#41;
                            &amp;#40;range width&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:private cell-class &amp;#91;position food-position snake-body-positions&amp;#93;
  &amp;#40;cond
    &amp;#40;= position food-position&amp;#41;          &amp;quot;food&amp;quot;
    &amp;#40;get snake-body-positions position&amp;#41; &amp;quot;snake&amp;quot;
    :else                               &amp;quot;empty&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;over&quot;&gt;&lt;/a&gt;Game Over&lt;/h3&gt;When the game is over, an overlay is added on top of the board with a replay button.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game-over &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;running? &amp;#40;subscribe &amp;#91;:running?&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;&amp;#93;
      &amp;#40;if @running?
        &amp;#91;:div&amp;#93;
        &amp;#91;:div.overlay
         &amp;#91;:div.play {:on-click #&amp;#40;dispatch &amp;#91;:start-game&amp;#93;&amp;#41;}
          &amp;#91;:h1 &amp;quot;âº&amp;quot;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;game&quot;&gt;&lt;/a&gt;Game&lt;/h3&gt;The main view is then composed of the different components.&lt;pre&gt;&lt;code&gt;&amp;#40;defn game &amp;#91;&amp;#93;
  &amp;#91;:div.game
   &amp;#91;score&amp;#93;
   &amp;#91;board&amp;#93;
   &amp;#91;game-over&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;The components are then mounted to the DOM with the function &lt;code&gt;run&lt;/code&gt; defined below.The main entrypoint of an re-frame app is the &lt;code&gt;init&lt;/code&gt; function.&lt;pre&gt;&lt;code&gt;&amp;#40;defn run &amp;#91;&amp;#93;
  &amp;#40;reagent/render &amp;#91;views/game&amp;#93;
                  &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;game&amp;#95;loop&quot;&gt;&lt;/a&gt;Game Loop&lt;/h2&gt;The game loop is handled with a set-interval call that will create a new game state based on the current one. That state will then be handled by React (Reagent) and the view will get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;defonce snake-moving
   &amp;#40;js/setInterval #&amp;#40;dispatch &amp;#91;:next-state&amp;#93;&amp;#41; 100&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Every 100ms, the message :next-state is sent to the handler.&lt;h2&gt;&lt;a name=&quot;handlers&quot;&gt;&lt;/a&gt;Handlers&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;game&amp;#95;initialization&quot;&gt;&lt;/a&gt;Game Initialization&lt;/h3&gt;In order to initialize the game, a handler &lt;code&gt;:start-game&lt;/code&gt; is created. It resets the initial state.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler :start-game &amp;#40;fn  &amp;#91;&amp;#95; &amp;#95;&amp;#93; &amp;#40;db/init-state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And the &lt;code&gt;init&lt;/code&gt; function is updated accordingly.&lt;pre&gt;&lt;code&gt;&amp;#40;defn &amp;#94;:export init &amp;#91;&amp;#93;
  &amp;#40;dispatch-sync &amp;#91;:start-game&amp;#93;&amp;#41;
  &amp;#40;run&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;changing&amp;#95;direction&quot;&gt;&lt;/a&gt;Changing Direction&lt;/h3&gt;When a player interacts with the keyboard (Up, Down, Left, Right or h, j, k, l for vim users), the direction of the snake should get updated.&lt;pre&gt;&lt;code&gt;&amp;#40;register-handler
   :change-direction
   &amp;#40;fn &amp;#91;db &amp;#91;&amp;#95; direction&amp;#93;&amp;#93;
      &amp;#40;assert &amp;#40;get #{:up :down :left :right} direction&amp;#41;&amp;#41;
      &amp;#40;assoc-in db &amp;#91;:snake :direction&amp;#93; direction&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;A handler is just a reducer function that takes in the value of the app-state &lt;code&gt;db&lt;/code&gt; and an action and returns a new app-state.Then, a keyboard listener is defined to catch the keystrokes mentioned above.&lt;pre&gt;&lt;code&gt;&amp;#40;def key-code-&amp;gt;move
   &amp;quot;Mapping from the integer key code to the direction keyword&amp;quot;
   {38  :up   ; Up Arrow
    75  :up   ; k
    40  :down ; Down Arrow
    74  :down ; j
    39  :right ; Right Arrow
    76  :right ; l
    37  :left  ; Left Arrow
    72  :left  ; h
    }&amp;#41;

&amp;#40;defonce key-handler
   &amp;#40;events/listen
      js/window
      &amp;quot;keydown&amp;quot;
      &amp;#40;fn  &amp;#91;e&amp;#93;
         &amp;#40;let &amp;#91;key-code &amp;#40;.-keyCode e&amp;#41;&amp;#93;
            &amp;#40;when &amp;#40;contains? key-code-&amp;gt;move key-code&amp;#41;
               &amp;#40;re-frame/dispatch &amp;#91;:change-direction &amp;#40;key-code-&amp;gt;move key-code&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;next&amp;#95;state&quot;&gt;&lt;/a&gt;Next State&lt;/h3&gt;The last thing to do is to implement the handler next-state that will move the snake given the direction and the state of the game.&lt;h4&gt;&lt;a name=&quot;collisions&quot;&gt;&lt;/a&gt;Collisions&lt;/h4&gt;The game is lost when the snake hits a wall or eats itself.&lt;pre&gt;&lt;code&gt;&amp;#40;defn collision? &amp;#91;snake board&amp;#93;
    &amp;#40;or &amp;#40;wall? next-head board&amp;#41; &amp;#40;eat-itself? snake&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn eat-itself? &amp;#91;{:keys &amp;#91;body&amp;#93; :as snake}&amp;#93;
  &amp;#40;boolean &amp;#40;get &amp;#40;into #{} body&amp;#41; &amp;#40;next-head-position snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn valid? &amp;#91;&amp;#91;x y :as position&amp;#93; &amp;#91;width height :as board&amp;#93;&amp;#93;
  &amp;#40;and &amp;#40;&amp;lt; -1 x width&amp;#41; &amp;#40;&amp;lt; -1 y height&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def wall? &amp;#40;complement valid?&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;re-frame/register-handler
   :next-state
   &amp;#40;fn &amp;#91;db &amp;#95;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;snake food board running?&amp;#93;} db&amp;#93;
         &amp;#40;cond
            &amp;#40;db/collision? snake board&amp;#41; &amp;#40;assoc db :running? false&amp;#41;
            &amp;#40;db/food? &amp;#40;db/next-head-position snake&amp;#41; food&amp;#41; &amp;#40;-&amp;gt; db
                                                              &amp;#40;update :points inc&amp;#41;
                                                              &amp;#40;update :snake db/move-snake&amp;#41;
                                                              &amp;#40;dissoc :food&amp;#41;
                                                              &amp;#40;update :snake db/grow-snake snake&amp;#41;
                                                              &amp;#40;db/rand-food&amp;#41;&amp;#41;
            :else &amp;#40;update db :snake db/move-snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;move-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn next-head-position
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;x y :as pos&amp;#93; &amp;#40;first body&amp;#41;&amp;#93;
    &amp;#40;case direction
      :left  &amp;#91;&amp;#40;dec x&amp;#41; y&amp;#93;
      :right &amp;#91;&amp;#40;inc x&amp;#41; y&amp;#93;
      :up    &amp;#91;x &amp;#40;dec y&amp;#41;&amp;#93;
      :down  &amp;#91;x &amp;#40;inc y&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn move-snake
  &amp;#91;{:keys &amp;#91;body direction&amp;#93; :as snake}&amp;#93;
  &amp;#40;update snake :body &amp;#40;fn &amp;#91;body&amp;#93; &amp;#40;cons &amp;#40;next-head-position snake&amp;#41;
                                       &amp;#40;drop-last body&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Here is the implementation of &lt;code&gt;grow-snake&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn grow-snake
  &amp;#91;snake previous-snake&amp;#93;
  &amp;#40;update snake :body concat &amp;#91;&amp;#40;last &amp;#40;:body previous-snake&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;And finally, here is &lt;code&gt;rand-food&lt;/code&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn rand-food &amp;#91;{:keys &amp;#91;snake board&amp;#93; :as state}&amp;#93;
  &amp;#40;assoc state :food &amp;#40;rand-free-position board &amp;#40;:body snake&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;development&amp;#95;environment&quot;&gt;&lt;/a&gt;Development Environment&lt;/h2&gt;Something that is often not discussed is tooling. Tools are everything. I spent a lot of time fine tuning my environment to increase my productiviy.To be honest, the ecosystem and tooling around Clojure and ClojureScript are just amazing.&lt;h3&gt;&lt;a name=&quot;figwheel&quot;&gt;&lt;/a&gt;Figwheel&lt;/h3&gt;To develop this game I used &lt;a href='https://github.com/bhauman/lein-figwheel'&gt;figwheel&lt;/a&gt; which enables live pushes to the clients. Here is a &lt;a href='https://www.youtube.com/watch?v=KZjFVdU8VLI'&gt;quick demo&lt;/a&gt; of interactive development in ClojureScript.&lt;p&gt;This is what my workflow looks like when developing:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Type something in my text-editor&lt;/li&gt;&lt;li&gt;Save changes&lt;/li&gt;&lt;li&gt;See live changes in the browser&lt;ul&gt;&lt;li&gt;live code reloading&lt;/li&gt;&lt;li&gt;live CSS reloading&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Repeat until done&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I get instant feedback without leaving my text editor!&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/img/snake/liveupdate.png&quot; alt=&quot;Dev Environment&quot; title=&quot;Figwheel and Interactive Development&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;end&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;Re-frame is a well thought out combination of &lt;strong&gt;reactive programming&lt;/strong&gt;, &lt;strong&gt;functional programming&lt;/strong&gt; and &lt;strong&gt;immutable data&lt;/strong&gt;.&lt;p&gt;It lets developers focus on the core application in a beautifully simple way. Re-frame emerged from ideas developed in Om, Elm and Flux that we are going to study next.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;pros&quot;&gt;&lt;/a&gt;Pros&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Clojure â¤&lt;ul&gt;&lt;li&gt;Immutability&lt;/li&gt;&lt;li&gt;Lisp&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Local states are just atoms captured in a closure. Local states can be shared between components.&lt;/li&gt;&lt;li&gt;Reagent is faster than React: All the checks for changes are pointer comparison (thanks to Clojure's immutability)&lt;/li&gt;&lt;li&gt;Pure functions: the side effects are pushed to the system's boundary. They should only exist in the event handlers.&lt;/li&gt;&lt;li&gt;Composition via reactive data flows (unidirectional graph)&lt;/li&gt;&lt;li&gt;Extremely simple (200 lines of code to implement re-frame)&lt;/li&gt;&lt;li&gt;Decomplects view, state, business logic in a functional way&lt;h3&gt;&lt;a name=&quot;cons&quot;&gt;&lt;/a&gt;Cons&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;The views are only in Hiccup Style for now (Clojure Data Structure). That is hard for designers to create their own components...&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 29 Feb 2016 00:00:00 -0800
</pubDate>
</item>
</channel>
</rss>
